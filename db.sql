/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.19-0ubuntu0.16.04.1 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;

USE `blog`;

/*Table structure for table `articlepic` */

DROP TABLE IF EXISTS `articlepic`;

CREATE TABLE `articlepic` (
  `pic` varchar(45) COLLATE utf8_unicode_ci NOT NULL,
  `articleid` int(10) unsigned DEFAULT NULL,
  PRIMARY KEY (`pic`),
  KEY `_index` (`articleid`),
  CONSTRAINT `articlepic_articles_id_fk` FOREIGN KEY (`articleid`) REFERENCES `articles` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `articlepic` */

insert  into `articlepic`(`pic`,`articleid`) values ('26cf4c86-7a59-4bcb-bc5e-ee4b456fc6e2.png',NULL),('926c4105-ebaf-4e0a-b66b-94727457c2df.png',NULL),('9c5e8850-f98f-403f-89ed-36d2e7ddf1b8.png',NULL),('9fb7a629-c74d-4583-86ec-38f3f9686ed7.png',NULL),('c3b0cddc-512b-455f-a905-59baaa8dadfe.png',NULL),('da34a95f-d7ad-4821-b91c-a56712f7a301.png',NULL),('a4a19722-66ae-46b3-aab2-fcd1c7229928.jpg',2),('0b48ad90-3a17-4c24-badb-055d68b1587e.jpg',5);

/*Table structure for table `articles` */

DROP TABLE IF EXISTS `articles`;

CREATE TABLE `articles` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `type` char(10) COLLATE utf8_unicode_ci DEFAULT NULL,
  `title` char(255) CHARACTER SET utf8 DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `summary` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `content` longtext COLLATE utf8_unicode_ci,
  `read_count` int(10) DEFAULT '0',
  `author` varchar(25) COLLATE utf8_unicode_ci DEFAULT NULL,
  `cover` varchar(45) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `type` (`type`),
  KEY `author` (`author`),
  CONSTRAINT `authoe_idx` FOREIGN KEY (`author`) REFERENCES `user` (`username`) ON UPDATE CASCADE,
  CONSTRAINT `type_idx` FOREIGN KEY (`type`) REFERENCES `type` (`type`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `articles` */

insert  into `articles`(`id`,`type`,`title`,`date`,`update_time`,`summary`,`content`,`read_count`,`author`,`cover`) values (2,'java','Java代理的实现','2017-08-07 17:31:37','2017-08-18 19:39:42','分别使用JDK和Cglib实现Java的动态代理','<h2><img alt=\"\" src=\"/userImg/ArticlePic?fileName=a4a19722-66ae-46b3-aab2-fcd1c7229928.jpg\" style=\"height:449px; width:800px\" /></h2>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>JDK动态代理的实现步骤：</h2>\r\n\r\n<p>1.创建一个实现接口 InvocationHandler 的类，他必须实现invoke方法；<br />\r\n2.创建被代理的类以及接口;<br />\r\n3.调用Proxy的静态方法，创建一个代理类</p>\r\n\r\n<pre>\r\n                <code>\r\n/**\r\n* laoder 类加载器 \r\n\r\n* interfaces 类的实现接口 \r\n\r\n* h InvocationHandler \r\n\r\n*/\r\n\r\nnewProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)\r\n\r\n                </code>\r\n            </pre>\r\n\r\n<p>4.通过代理调用方法;</p>\r\n\r\n<p>jdk动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该接口中定义的方法实现代理，这是实际编程中有一定的局限性。</p>\r\n\r\n<h2>Cglib实现：</h2>\r\n\r\n<p>使用cglib【Code Generation Library】实现动态代理，并不要求委托类必须实现接口第层采用asm字节码生成框架生成代理类的字节码</p>\r\n\r\n<h3>1.定义业务逻辑</h3>\r\n\r\n<pre>\r\n                    <code>\r\npublic class UserServiceImpl{\r\n    public void add(){\r\n        System.out.println(&quot;This is add service&quot;);\r\n    }\r\n    public void delete(int id){\r\n        System.out.println(&quot;This is delete service,delete:&quot; + id);\r\n    }\r\n                        }\r\n\r\n                    </code>\r\n                </pre>\r\n\r\n<h3>2.实现MethodInterceptor接口，定义方法的拦截器</h3>\r\n\r\n<pre>\r\n                    <code>\r\npublic class MyMethodInterceptor implements MethodInterceptor{\r\n	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy){\r\n		System.out.println(&quot;Before:&quot; + method);\r\n		Obect obj = proxy.invokeSuper(obj,args);\r\n		System.out,println(&quot;After:&quot; + method);\r\n		return obj;\r\n	}\r\n}\r\n                    </code>\r\n                </pre>\r\n\r\n<h3>3.使用Enhancer类生成代理类：</h3>\r\n\r\n<pre>\r\n                    <code>\r\nEnhancer enhancer = new Enhancer();\r\nenhancer.setSuperclass(UserServiceImpl.class);\r\nenhancer.setCallback(new MymethodInterceptor());\r\nUserServoceImpl userService = (UserServiceImpl)enhancer.create();\r\n                    </code>\r\n                </pre>\r\n\r\n<h3>4.使用userService.add()的执行结果：</h3>\r\n\r\n<pre>\r\n                    <code>\r\nBefore: add\r\nThis is add service\r\nAfter: add\r\n                    </code>\r\n                </pre>\r\n\r\n<p>代理对象的生成过程由Enhancer类实现，大概步骤如下：<br />\r\n1、生成代理类Class的二进制字节码；<br />\r\n2、通过Class.forName加载二进制字节码，生成Class对象；<br />\r\n3、通过反射机制获取实例构造，并初始化代理类对象。</p>\r\n',43,'孟祥坤','59afe82d-790d-4b78-a63e-47b4ede5f208.jpg'),(3,'数据库','Mybatis使用中出现的一些问题','2017-08-10 15:46:16','2017-08-16 11:11:45','初学Mybatis碰见的一些坑','<h2>Mybatis中的排序问题（ORDER BY)</h2>\r\n\r\n<p>1.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #{user_id}，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, 如果传入的值是id，则解析成的sql为order by &quot;id&quot;。<br />\r\n2.$将传入的数据直接显示生成在sql中。如：order by ${user_id}，如果传入的值是111,那么解析成sql时的值为order by 111, 如果传入的值是id，则解析成的sql为order by id。<br />\r\n3.#方式能够很大程度防止sql注入。<br />\r\n$方式无法防止Sql注入。<br />\r\n4.$方式一般用于传入数据库对象，例如传入表名。<br />\r\n5.一般能用#的就别用$。</p>\r\n\r\n<h2>支持的 JDBC 类型:</h2>\r\n\r\n<p>为了未来的参考,MyBatis 通过包含的 jdbcType 枚举型,支持下面的 JDBC 类型</p>\r\n\r\n<pre>\r\nBIT FLOAT   CHAR    TIMESTAMP   OTHER   UNDEFINED\r\n\r\nTINYINT REAL    VARCHAR BINARY  BLOB    NVARCHAR\r\n\r\nSMALLINT    DOUBLE  LONGVARCHAR VARBINARY   CLOB    NCHAR\r\n\r\nINTEGER NUMERIC DATE    LONGVARBINARY   BOOLEAN NCLOB\r\n\r\nBIGINT  DECIMAL TIME    NULL    CURSOR  ARRAY\r\n\r\n                                    </pre>\r\n\r\n<p>其中DATE和TIME都只支持DATE和TIME^_^(即只能表示日期或者时间，TIMESTAMP能表示日期加时间)</p>\r\n\r\n<h2>set元素的操作</h2>\r\n\r\n<p>set元素主要是用在更新操作的时候，它的主要功能和where元素其实是差不多的，主要是在包含的语句前输出一个set，然后如果包含的语句是以逗号结束的话将会把该逗号忽略，如果set包含的内容为空的话则会出错。有了set元素我们就可以动态的更新那些修改了的字段。下面是一段示例代码：</p>\r\n\r\n<p><pre>&lt;update id=&quot;dynamicSetTest&quot; parameterType=&quot;Blog&quot;&gt;\r\n    update t_blog\r\n    &lt;set&gt;\r\n        &lt;if test=&quot;title != null&quot;&gt;\r\n            title = #{title},\r\n        &lt;/if&gt;\r\n        &lt;if test=&quot;content != null&quot;&gt;\r\n            content = #{content},\r\n        &lt;/if&gt;\r\n        &lt;if test=&quot;owner != null&quot;&gt;\r\n            owner = #{owner}\r\n        &lt;/if&gt;\r\n    &lt;/set&gt;\r\n    where id = #{id}\r\n&lt;/update&gt;\r\n                                    </pre></p>\r\n<p>上述示例代码中，如果set中一个条件都不满足，即set中包含的内容为空的时候就会报错。</p>\r\n\r\n                                    <!--<div class=\"col-lg-4 animate-box\">-->\r\n                                    <div class=\"gtco-highlight right\">\r\n                                        <h4>使用Mybatis时编程注意</h4>\r\n                                        <p>健壮的程序要经过全面的测试，主观臆断不可取</p>\r\n                                    </div>\r\n                                    <!--</div>-->\r\n                                    <h2>Tips</h2>\r\n                                    <p>\r\n                                        如果要返回一个List&lt;String&gt;,ResultType=\"String\"即可。<br>\r\n                                        <br>\r\n                                        int型的数据默认为0不能判断是否为Null，需要判断为Null时使用Integer更好，要注意getter返回值也要为Integer，不然会自动拆装箱。<br>\r\n                                        <br>\r\n                                        <code>java.lang.IllegalArgumentException: Mapped Statements collection does not\r\n                                            contain value for ****</code><br>\r\n                                        出现这种错误，可能是mybatis的namespace与类中的名称不一致，一字之差导致异常的发生<br>\r\n                                        <br>\r\n                                        总结：细心，认真，冷静是程序开发之根本。<br>\r\n                                        <br>\r\n                                        如果莫名其妙的出现错误，一定要冷静！冷静！！，在仔细看看（麻痹的尤其是那个resultMap!!!)<br>\r\n                                        <br>\r\n                                        解决问题的过程是煎熬的，令人想吐的！ 但还好，结果是令人欣慰的^_^（附歌一首  阴霾散却，云尽日出)<br>\r\n                                        <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330\r\n                                                height=86\r\n                                                src=\"http://music.163.com/outchain/player?type=2&id=31838901&auto=0&height=66\"></iframe>\r\n                                        <br>\r\n                                        妈的开心！<br>\r\n                                    </p>\r\n\r\n',15,'孟祥坤','5cf30b14-3a67-4059-817d-d48c3311ec0d.png'),(4,'数据库','MySql的那些坑','2017-08-10 15:49:34','2017-08-16 11:50:39','Linux下Mysql的一些设置','<h2>Ubuntu上为MySql设置字符编码格式</h2>\r\n\r\n<p>文件位置 /etc/mysql/conf.d/mysql.cnf</p>\r\n\r\n<h2>无法连接到MySql可能的原因：</h2>\r\n\r\n<p>Mysql的3306端口只对本地主机127.0.0.1监听，解决方案：</p>\r\n\r\n<div class=\"gtco-highlight right\">1 在目标服务器上（192.168.1.11），修改mysql的my.cnf文件：<br />\r\nsudo vi /etc/mysql/my.cnf<br />\r\n<br />\r\n2 注释掉bind-address，屏蔽其只对本地监听<br />\r\n#bind-address = 127.0.0.1<br />\r\n<br />\r\n3 启动MySQL服务，使其修改的配置生效</div>\r\n\r\n<h2>MySql与Mybatis一起使用可能出现的问题</h2>\r\n\r\n<p>mysql数据库的表明与列名严格区分大小写，而mybatis中的表名开头大写，很坑爹<br />\r\n解决方案:</p>\r\n\r\n<div class=\"gtco-highlight right\">在/etc/mysql/my.cnf 的【mysqld】中加一句lower_case_table_names=1即可不区分大小写</div>\r\n',41,'孟祥坤','5431f616-b956-48a1-9234-7fcf723884e1.png'),(5,'Linux','VIM使用相关','2017-08-10 15:50:25','2017-08-16 11:29:12','关于VIM编辑器的一些技巧','<h2>VIM使用管理员权限强行写入文件</h2>\r\n\r\n<p>底行命令模式执行：:w !sudo tee %</p>\r\n\r\n<p>w： 表示保存文件<br />\r\n！： 表示执行外部命令<br />\r\ntee： linux命令，这个有点复杂，可以查看linux命令帮助<br />\r\n%： 在执行外部命令时，%会扩展成当前文件名；这个%区别于替换时的%，替换时%的意义是代表整个文件，而不是文件名</p>\r\n\r\n<h1>常用命令：</h1>\r\n\r\n<div class=\"gtco-highlight right\"><img alt=\"\" src=\"/userImg/ArticlePic?fileName=0b48ad90-3a17-4c24-badb-055d68b1587e.jpg\" style=\"height:927px; width:1000px\" /></div>\r\n\r\n<p>&nbsp;</p>\r\n',19,'孟祥坤','bc4981fb-04e7-4cd1-ac0c-52097d8f00f9.png'),(6,'java','jsp:usebean标签','2017-08-10 16:47:02',NULL,'jsp:usebean标签的几种不同形式用法详解','\r\n\r\n                                <!--文本段落-->\r\n                                <h1>&lt;jsp:usebean&gt;标签的用法详解</h1>\r\n\r\n                                <code>1.&lt;jsp:useBean class=\"MyBean.TestBean\" id=\"user\" scope=\"session\"/&gt;</code>\r\n\r\n                                <p>\r\n                                    生成的Java代码如下：\r\n                                </p>\r\n                                <pre><code>\r\nMyBean.TestBean user = null;\r\n      synchronized (session) {\r\n        user = (MyBean.TestBean) _jspx_page_context.getAttribute(\"user\", javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        if (user == null){\r\n          user = new MyBean.TestBean();\r\n          _jspx_page_context.setAttribute(\"user\", user, javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        }\r\n      }\r\n                                </code></pre>\r\n                                <p>先从session范围内查找user属性是否存在，如果不存在，user = new\r\n                                    MyBean.TestBean()，然后把user追加到session中。<br>存在的话，啥也不做。</p>\r\n\r\n                                <code>2.&lt;jsp:useBean type=\"BaseBean\" class=\"MyBean.TestBean\" id=\"user\"\r\n                                    scope=\"session\"/&gt;</code>\r\n\r\n                                <p>生成的Java代码如下：</p>\r\n                                <pre><code>\r\nBaseBean user = null;\r\n      synchronized (session) {\r\n        user = (BaseBean) _jspx_page_context.getAttribute(\"user\", javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        if (user == null){\r\n          user = new MyBean.TestBean();\r\n          _jspx_page_context.setAttribute(\"user\", user, javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        }\r\n      }\r\n                                </code></pre>\r\n                                <p>BaseBean是TestBean的父类。<br>\r\n                                    除了user的类型是BaseBean，其它的处理逻辑和《1》相同。\r\n                                </p>\r\n                                <code>3.&lt;jsp:useBean type=\"MyBean.BaseBean\" beanName=\"MyBean.TestBean\" id=\"user\"\r\n                                    scope=\"session\"/&gt;</code>\r\n                                <p>生成的Java代码如下</p>\r\n                                <pre><code>\r\nMyBean.BaseBean user = null;\r\n      synchronized (session) {\r\n        user = (MyBean.BaseBean) _jspx_page_context.getAttribute(\"user\", javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        if (user == null){\r\n          try {\r\n            user = (MyBean.BaseBean) java.beans.Beans.instantiate(this.getClass().getClassLoader(), \"MyBean.TestBean\");\r\n          } catch (java.lang.ClassNotFoundException exc) {\r\n            throw new InstantiationException(exc.getMessage());\r\n          } catch (java.lang.Exception exc) {\r\n            throw new javax.servlet.ServletException(\"Cannot create bean of class \" + \"MyBean.TestBean\", exc);\r\n          }\r\n          _jspx_page_context.setAttribute(\"user\", user, javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        }\r\n      }\r\n                                </code></pre>\r\n                                <p>\r\n                                    和2>的区别如下：<br>\r\n                                    1>不使用new关键字进行创建，而是使用Beans.instantiate来加载并实例化对象<br>\r\n                                    2>对象创建完以后进行了强制类型转换(MyBean.BaseBean)<br>\r\n                                </p>\r\n                                <code>4.&lt;jsp:useBean type=\"MyBean.BaseBean\" id=\"user\" scope=\"session\"/&gt;</code>\r\n                                <p>生成的代码如下</p>\r\n                                <pre><code>\r\nMyBean.BaseBean user = null;\r\n      synchronized (session) {\r\n        user = (MyBean.BaseBean) _jspx_page_context.getAttribute(\"user\", javax.servlet.jsp.PageContext.SESSION_SCOPE);\r\n        if (user == null){\r\n          throw new java.lang.InstantiationException(\"bean user not found within scope\");\r\n        }\r\n      }\r\n                                </code></pre>\r\n                                <p>\r\n                                    先从session范围内查找user属性，如果不存在就直接抛出异常，存在的话直接引用。\r\n                                </p>\r\n',13,'孟祥坤',NULL),(8,'java','数据库连接超时异常处理','2017-08-10 19:38:59','2017-08-16 11:07:20','MySql长时间未活动连接自动关闭的解决方案','<!--文本段落-->\r\n<h1>Mybatis配合Mysql经常断开链接的问题</h1>\r\n\r\n<p>最近网站每天第一次打开的时候总会报如下异常：</p>\r\n\r\n<p><code>### The error occurred while executing a query ### Cause: org.apache.ibatis.transaction.TransactionException: Error configuring AutoCommit. Your driver may not support getAutoCommit() or setAutoCommit(). Requested setting: false. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure </code></p>\r\n\r\n<p><br />\r\n执行刷新操作之后异常消失,非常诡异。<br />\r\n同样的问题也出现在打开的网页好长时间没有动的情况下，搜索之后了解到这是因为Mysql存在最大超时限制，默认为8小时<br />\r\n八小时内链接无活动就会自动断开连接，而MyBatis使用的是连接池，在数据库单方面断开链接后客户端并不知情，再次访问时使用连接池中的链接就会报出上述异常</p>\r\n\r\n<div class=\"gtco-highlight right\">\r\n<h4>解决思路:</h4>\r\n\r\n<p>1.增加Mysql的连接超时时间，查看mysql5的手册，发现对wait_timeout的最大值分别是24天/365天(windows/linux)。<br />\r\n2.使链接一直处于活动状态，可在Java代码中设置定时查询，链接闲置一段时间后自动执行查询语句，这是一种解决方案。<br />\r\n3.在Mybatis自带的连接池配置中，设置属性可以在使用一个闲置链接前对他Ping一下，确保他还在正常工作。</p>\r\n</div>\r\n\r\n<p><textarea cols=\"100\" rows=\"13\">&lt;environment id=&quot;development&quot;&gt;\r\n   &lt;transactionManager type=&quot;jdbc&quot;/&gt;\r\n   &lt;dataSource type=&quot;POOLED&quot;&gt;\r\n       &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\r\n       &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/kpi?autoReconnect=true&quot;/&gt;\r\n       &lt;property name=&quot;username&quot; value=&quot;mysql&quot;/&gt;\r\n       &lt;property name=&quot;password&quot; value=&quot;mysql&quot;/&gt;\r\n       &lt;property name=&quot;poolPingEnabled&quot; value=&quot;true&quot;/&gt;\r\n       &lt;property name=&quot;poolPingQuery&quot; value=&quot;select now() from kpi.lastupdatedlog limit 1&quot;/&gt;\r\n       &lt;property name=&quot;poolPingConnectionsNotUsedFor&quot; value=&quot;3600000&quot;/&gt;\r\n   &lt;/dataSource&gt;\r\n&lt;/environment&gt;\r\n                                </textarea></p>\r\n',18,'孟祥坤','7d2178d0-62c5-40d9-84cd-9dca616358e8.png'),(40,'java','《c:forEach》的用法','2017-08-12 23:03:12','2017-08-18 19:39:15','c:forEach, c:forTokens 标签的用法详解','<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">\r\n<p>这些标签封装了Java中的for，while，do-while循环。</p>\r\n\r\n<p>相比而言，标签是更加通用的标签，因为它迭代一个集合中的对象。</p>\r\n\r\n<p>标签通过指定分隔符将字符串分隔为一个数组然后迭代它们。</p>\r\n</div>\r\n\r\n<h1>标签：</h1>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>语法格式：</p>\r\n\r\n<pre>\r\n\r\n\r\n    ...</pre>\r\n\r\n<h3>属性：</h3>\r\n\r\n<p>标签有如下属性：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<th><strong>属性</strong></th>\r\n			<th><strong>描述</strong></th>\r\n			<th><strong>是否必要</strong></th>\r\n			<th><strong>默认值</strong></th>\r\n		</tr>\r\n		<tr>\r\n			<td>items</td>\r\n			<td>要被循环的信息</td>\r\n			<td>否</td>\r\n			<td>无</td>\r\n		</tr>\r\n		<tr>\r\n			<td>begin</td>\r\n			<td>开始的元素（0=第一个元素，1=第二个元素）</td>\r\n			<td>否</td>\r\n			<td>0</td>\r\n		</tr>\r\n		<tr>\r\n			<td>end</td>\r\n			<td>最后一个元素（0=第一个元素，1=第二个元素）</td>\r\n			<td>否</td>\r\n			<td>Last element</td>\r\n		</tr>\r\n		<tr>\r\n			<td>step</td>\r\n			<td>每一次迭代的步长</td>\r\n			<td>否</td>\r\n			<td>1</td>\r\n		</tr>\r\n		<tr>\r\n			<td>var</td>\r\n			<td>代表当前条目的变量名称</td>\r\n			<td>否</td>\r\n			<td>无</td>\r\n		</tr>\r\n		<tr>\r\n			<td>varStatus</td>\r\n			<td>代表循环状态的变量名称</td>\r\n			<td>否</td>\r\n			<td>无</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h1>标签：</h1>\r\n\r\n<h3>语法格式</h3>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<p>标签与标签有相似的属性，不过还有另一个属性：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<th><strong>属性</strong></th>\r\n			<th><strong>描述</strong></th>\r\n			<th><strong>是否必要</strong></th>\r\n			<th><strong>默认值</strong></th>\r\n		</tr>\r\n		<tr>\r\n			<td>delims</td>\r\n			<td>分隔符</td>\r\n			<td>是</td>\r\n			<td>无</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>示例演示：</h2>\r\n\r\n<h2>实例演示</h2>\r\n\r\n<pre>\r\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\r\n    pageEncoding=&quot;UTF-8&quot;%&gt;\r\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;\r\n</pre>\r\n\r\n<p>c:forEach 标签实例 Item</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>运行结果如下：</p>\r\n\r\n<pre>\r\nItem 1\r\nItem 2\r\nItem 3\r\nItem 4\r\nItem 5</pre>\r\n\r\n<hr />\r\n<h2>演示实例</h2>\r\n\r\n<pre>\r\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\r\n    pageEncoding=&quot;UTF-8&quot;%&gt;\r\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;\r\n</pre>\r\n\r\n<p>c:forTokens 标签实例</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>运行结果如下：</p>\r\n\r\n<pre>\r\ngoogle\r\nrunoob\r\ntaobao</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>-----------本文摘自 http://www.runoob.com/jsp/jstl-core-foreach-tag.html ----------</p>\r\n',21,'孟祥坤','6aa009bc-8d36-44f5-a2eb-39414bdf6251.jpg'),(41,'java','为Linux加入Swap','2017-08-13 13:09:06','2017-08-16 11:15:27','如何为Linux系统增加分页文件','<h1>&nbsp;为Linux增加内存分页</h1>\r\n\r\n<h3>最近使用VPS时，启动Tomcat提示&nbsp;&ldquo;Cannot allocate memory&#39; (errno=12)&ldquo; ，再使用free和top命令查看内存使用情况，发现只有70多MB的内存可用（总共1GB/(ㄒoㄒ)/~~）但没钱购置更好的云虚机，同时发现这个虚拟机上没有Swap，于是查找了下如何为Linux添加分页文件，记录下来。</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:15.6px\">什么是Swap：</span></p>\r\n\r\n<h3 style=\"color:#aaaaaa; font-style:italic\"><br />\r\n<br />\r\n&nbsp;Swap是一種解決Server上OOM(out of memory)的一種方法， 取硬碟的某一區塊暫時作為記憶體使用，解決記憶體不足的問題。 由於硬碟速度不如記憶體，會將較舊少使用的資料存入Swap，而 較常新的資料留在記憶體。</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>查看当前Swap设定情况：</p>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">swapon -s&nbsp;</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">&nbsp;Filename&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Type&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Size &nbsp; &nbsp; &nbsp; &nbsp;Used &nbsp; &nbsp; &nbsp; &nbsp; Priority<br />\r\n/swapfile &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;file &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2047996&nbsp;&nbsp; &nbsp;215964&nbsp;&nbsp; &nbsp;-1</div>\r\n\r\n<p>查看当前内存及swap使用情况：</p>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">free -m</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">&nbsp;ubuntu@VM-78-99-ubuntu:~$ free -m<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;total &nbsp; &nbsp; &nbsp; &nbsp;used &nbsp; &nbsp; &nbsp; &nbsp;free &nbsp; &nbsp; &nbsp;shared &nbsp;buff/cache &nbsp; available<br />\r\nMem: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;864 &nbsp; &nbsp; &nbsp; &nbsp; 681 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;70 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; 111 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;51<br />\r\nSwap: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1999 &nbsp; &nbsp; &nbsp; &nbsp; 210 &nbsp; &nbsp; &nbsp; &nbsp;1789</div>\r\n\r\n<h1>建立Swap文件：</h1>\r\n\r\n<p>&nbsp;启用Swap前必须先建立一个档案，我们将建立一个名为<code>swapfile</code>的档案于根目录，配置此档案的大小即为Swap的大小，有以下两种方式来达到这件事：</p>\r\n\r\n<h3 style=\"text-align:start\"><span style=\"font-size:24px\"><strong><span style=\"color:#404040\"><span style=\"background-color:#ffffff\">一、dd指令(slow way)</span></span></strong></span></h3>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">使用<code>dd</code>指令来预先配置档案大小，这个指令将系统某个档案写到指定的地方，利用<code>/dev/zero</code>这个档案，它提供了无限的空字元可以让我们写入Swapfile，&nbsp;<code>bs</code>参数可以指定block的大小，<code>count</code>参数指定要几个block，因此&nbsp;<code>block*count=swap size</code>。bs与count可以是任意值，最重要的是相乘后应为你要的Swap size：</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo dd <strong><span style=\"color:#333333\"><strong>if</strong></span></strong><strong>=</strong>/dev/zero <span style=\"color:teal\">of</span><strong>=</strong>/swapfile <span style=\"color:teal\">bs</span><strong>=</strong>1G <span style=\"color:teal\"><span style=\"color:#0086b3\">count</span></span><strong>=</strong><span style=\"color:teal\">4</span></code></span></span></span></span></span></span></span></span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">若执行时产生如：<code>dd: memory exhausted by input buffer of size 1073741824 bytes (1.0 GiB)</code>&nbsp;的错误讯息，表示你的block size设太大，将bs降低然后提高count就可以解决</span></span></span></span></p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">执行成功后，会出现如下讯息，表示系统花了15秒将4GB的zero写入Swapfile</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code><span style=\"color:teal\">8</span>+<span style=\"color:teal\">0</span> records <strong><span style=\"color:#333333\"><strong>in</strong></span>\r\n</strong><span style=\"color:teal\">8</span>+<span style=\"color:teal\">0</span> records <span style=\"color:#333333\"><strong>out</strong></span>\r\n<span style=\"color:teal\">4294967296</span> bytes <strong>(</strong><span style=\"color:teal\">4.3</span> GB<strong>)</strong> copied, <span style=\"color:teal\">15.4326</span> s, <span style=\"color:teal\">278</span> MB/s\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">执行以下指令，可以看到我们产生了一个4GB的档案</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>ls -lh /swapfile\r\n<span style=\"color:#555555\"><span style=\"color:#333333\"><strong>=&gt;</strong></span> </span>-rw-r--r-- <span style=\"color:teal\">1</span> root root <span style=\"color:teal\">4.0</span>G <span style=\"color:teal\">Dec</span> <span style=\"color:teal\">29</span> <span style=\"color:teal\">04</span><span style=\"color:#990073\">:</span><span style=\"color:teal\">18</span> /swapfile\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">现在可以先将swapfile移除，我们要用更快的方法产生这个档案</span></span></span></span></p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\">&nbsp;</p>\r\n\r\n<h3 style=\"text-align:start\"><span style=\"font-size:24px\"><strong><span style=\"color:#404040\"><span style=\"background-color:#ffffff\">二、fallocate指令</span></span></strong></span></h3>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><code>fallocate</code>指令建立一个预先配置大小的档案，之所以快是因为不必将没用的内容写入档案。同样建立4GB档案只要输入以下指令：</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo fallocate -l <span style=\"color:teal\">4</span>G /swapfile\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">与上一次15秒相比，这次是立刻完成。（有些系统可能不支持这种方法）</span></span></span></span></p>\r\n\r\n<h2 style=\"text-align:start\"><span style=\"font-size:30px\"><strong><span style=\"color:#404040\"><span style=\"background-color:#ffffff\">启用S​​wap</span></span></strong></span></h2>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">建立完swapfile后要对这个档案启用Swap功能，先更改档案的权限， 让root只有读取的权限以避免安全性的问题：</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo <span style=\"color:#333333\"><strong>chmod</strong></span> <span style=\"color:teal\">600</span> /swapfile\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">透过<code>mkswap</code>指令，将档案作为swap</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo mkswap /swapfile\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">成功后便会看到如下讯息：</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>Setting up swapspace version <span style=\"color:teal\">1</span>, size <strong>=</strong> <span style=\"color:teal\">4194300</span> KiB\r\nno label, <span style=\"color:teal\">UUID</span><strong>=</strong><span style=\"color:teal\">56</span>ae31ba-b0f5-<span style=\"color:teal\">4</span>d21-<span style=\"color:teal\">943f</span>-<span style=\"color:teal\">0f</span>bc76ae79a7\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">最后使用<code>swapon</code>指令启用swap：</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo swapon /swapfile\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">透过以下指令可以看到Swap已经开始运作了</span></span></span></span></p>\r\n\r\n<div class=\"highlighter-rouge language-bash\" style=\"-webkit-text-stroke-width:0px; text-align:start\">\r\n<pre style=\"margin-left:0px; margin-right:0px\">\r\n<span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\"><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>sudo swapon -s\r\nFilename    Type    Size    Used    Priority\r\n/swapfile   file    <span style=\"color:teal\">4194300</span> <span style=\"color:teal\">0</span>       -<span style=\"color:teal\">1</span>\r\n</code></span></span></span></span></span></span></span></span></pre>\r\n</div>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">同样可以用<code>free -m</code>看到Swap那一列不再是0</span></span></span></span></p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\">&nbsp;</p>\r\n\r\n<h2 style=\"text-align:start\"><span style=\"font-size:30px\"><strong><span style=\"color:#404040\"><span style=\"background-color:#ffffff\">让Swap档案永久运作</span></span></strong></span></h2>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px; text-align:start\"><span style=\"font-size:20px\"><span style=\"color:#404040\"><span style=\"font-family:Lora,\"><span style=\"background-color:#ffffff\">swap已经启用了，但重新开机后server不会自动启用它，修改&nbsp;<code>/etc/fstab</code>档案来达成永久启用，在档案的底端加入：</span></span></span></span></p>\r\n\r\n<pre style=\"margin-left:0px; margin-right:0px; text-align:start\">\r\n<span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>/swapfile   none    swap    sw  0   0</code></span></span></span></span></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><q><span style=\"font-size:13px\"><span style=\"font-family:Menlo,Monaco,Consolas,\"><span style=\"color:#333333\"><span style=\"background-color:#f8f8f8\"><code>参考https://blog.json.tw/setting-swap-for-vps</code></span></span></span></span></q></p>\r\n</div>\r\n',7,'孟祥坤','24cf93dc-4024-403b-b96c-be4453fd8711.png'),(42,'生活点滴','博客搭建','2017-08-13 15:52:49','2017-08-23 23:18:06','博客搭建过程记录 ','<h2 style=\"font-style:italic\"><q><span style=\"font-size:16pt\"><span style=\"color:#4472c4\"><em>开发手记</em></span></span></q></h2>\r\n\r\n<ol>\r\n	<li style=\"text-align:justify\">\r\n	<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">前四天使用简单的servlet和jdbc配合JSP完成了一个简单的博客网站，实现了简单的查看文章，排序，分页与推荐阅读，但整体结构比较混乱，没有实现登录与发文功能。</span></span><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">随后先学习了MyBatis框架，并将网站的Model层用MyBatis重写，刚开始使用还很不熟练，重写的过程中遇到了很多问题，使用我的博客记录了下来，供以后参考。</span></span></div>\r\n	</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol start=\"3\">\r\n	<li style=\"text-align:justify\">\r\n	<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">由于刚开始对JSTL不熟悉，所以网站的视图层用了JSP和java代码混合的形式来写，结构非常混乱。所以后来使用JSTL对网站的前端页面重写，并对结构进行了一些调整。</span></span></div>\r\n	</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol start=\"4\">\r\n	<li style=\"text-align:justify\">\r\n	<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">学习Spring MVC，重写网站的Control层，并学习使用Maven管理项目，同时将这些天遇到的一些问题记录在博客上。</span></span></div>\r\n	</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol start=\"5\">\r\n	<li style=\"text-align:justify\">\r\n	<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">进行用户登录与发文功能的添加，使用CKEditor作为文章编辑器。</span></span></div>\r\n	</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol start=\"6\">\r\n	<li style=\"text-align:justify\">\r\n	<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">网站的整体架构感觉还是很乱，主要是文章的查看与发表功能不是同时添加的，刚开始很多方面没有考虑到，比如资源的存放位置等，</span></span></div>\r\n	</li>\r\n</ol>\r\n\r\n<p><span style=\"font-size:10.5pt\"><span style=\"font-family:等线\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></span></p>\r\n',21,'孟祥坤','e5603ab9-7c8d-43b5-955f-a9b4e33b2623.png'),(49,'java','Log4j配置文件详解','2017-08-16 16:30:18','2017-08-16 16:32:48','Log4J的配置文件(Configuration File)就是用来设置记录器的级别、存放器和布局的，它可接key=value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境','<p>1. 配置文件<br />\r\nLog4J配置文件的基本格式如下：</p>\r\n\r\n<p>#配置根Logger<br />\r\nlog4j.rootLogger &nbsp;= &nbsp; [ level ] &nbsp; , &nbsp;appenderName1 , &nbsp;appenderName2 , &nbsp;&hellip;</p>\r\n\r\n<p>#配置日志信息输出目的地Appender<br />\r\nlog4j.appender.appenderName &nbsp;= &nbsp;fully.qualified.name.of.appender.class&nbsp;<br />\r\n　　log4j.appender.appenderName.option1 &nbsp;= &nbsp;value1&nbsp;<br />\r\n　　&hellip;&nbsp;<br />\r\n　　log4j.appender.appenderName.optionN &nbsp;= &nbsp;valueN&nbsp;</p>\r\n\r\n<p>#配置日志信息的格式（布局）<br />\r\nlog4j.appender.appenderName.layout &nbsp;= &nbsp;fully.qualified.name.of.layout.class&nbsp;<br />\r\n　　log4j.appender.appenderName.layout.option1 &nbsp;= &nbsp;value1&nbsp;<br />\r\n　　&hellip;&nbsp;<br />\r\n　　log4j.appender.appenderName.layout.optionN &nbsp;= &nbsp;valueN&nbsp;</p>\r\n\r\n<p>其中 [level] 是日志输出级别，共有5级：</p>\r\n\r\n<p>FATAL &nbsp; &nbsp; &nbsp; 0 &nbsp;<br />\r\nERROR &nbsp; &nbsp; &nbsp;3 &nbsp;<br />\r\nWARN &nbsp; &nbsp; &nbsp; 4 &nbsp;<br />\r\nINFO &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp;<br />\r\nDEBUG &nbsp; &nbsp; &nbsp;7&nbsp;</p>\r\n\r\n<p><br />\r\nAppender 为日志输出目的地，Log4j提供的appender有以下几种：<br />\r\n&nbsp;org.apache.log4j.ConsoleAppender（控制台），<br />\r\norg.apache.log4j.FileAppender（文件），<br />\r\norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），<br />\r\norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），<br />\r\norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</p>\r\n\r\n<p>Layout：日志输出格式，Log4j提供的layout有以下几种：<br />\r\n&nbsp;org.apache.log4j.HTMLLayout（以HTML表格形式布局），<br />\r\norg.apache.log4j.PatternLayout（可以灵活地指定布局模式），<br />\r\norg.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），<br />\r\norg.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p>\r\n\r\n<p>打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下:</p>\r\n\r\n<p>&nbsp;　&nbsp; %m &nbsp; 输出代码中指定的消息<br />\r\n　　%p &nbsp; 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL&nbsp;<br />\r\n　　%r &nbsp; 输出自应用启动到输出该log信息耗费的毫秒数&nbsp;<br />\r\n　　%c &nbsp; 输出所属的类目，通常就是所在类的全名&nbsp;<br />\r\n　　%t &nbsp; 输出产生该日志事件的线程名&nbsp;<br />\r\n　　%n &nbsp; 输出一个回车换行符，Windows平台为&ldquo;\\r\\n&rdquo;，Unix平台为&ldquo;\\n&rdquo;&nbsp;<br />\r\n　　%d &nbsp; 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 &nbsp;22 ： 10 ： 28 ， 921 &nbsp;<br />\r\n　　%l &nbsp; 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )&nbsp;</p>\r\n\r\n<p>2. 在代码中初始化Logger:&nbsp;<br />\r\n1）在程序中调用BasicConfigurator.configure()方法：给根记录器增加一个ConsoleAppender，输出格式通过PatternLayout设为&quot;%-4r [%t] %-5p %c %x - %m%n&quot;，还有根记录器的默认级别是Level.DEBUG.&nbsp;<br />\r\n2）配置放在文件里，通过命令行参数传递文件名字，通过PropertyConfigurator.configure(args[x])解析并配置；<br />\r\n3）配置放在文件里，通过环境变量传递文件名等信息，利用log4j默认的初始化过程解析并配置；<br />\r\n4）配置放在文件里，通过应用服务器配置传递文件名等信息，利用一个特殊的servlet来完成配置。</p>\r\n\r\n<p>3. 为不同的 Appender 设置日志输出级别：<br />\r\n当调试系统时，我们往往注意的只是异常级别的日志输出，但是通常所有级别的输出都是放在一个文件里的，如果日志输出的级别是BUG！？那就慢慢去找吧。<br />\r\n这时我们也许会想要是能把异常信息单独输出到一个文件里该多好啊。当然可以，Log4j已经提供了这样的功能，我们只需要在配置中修改Appender的Threshold 就能实现,比如下面的例子：</p>\r\n\r\n<p>[配置文件]</p>\r\n\r\n<p>&nbsp;### set log levels ###<br />\r\nlog4j.rootLogger = debug , &nbsp;stdout , &nbsp;D , &nbsp;E</p>\r\n\r\n<p>### 输出到控制台 ###<br />\r\nlog4j.appender.stdout = org.apache.log4j.ConsoleAppender<br />\r\nlog4j.appender.stdout.Target = System.out<br />\r\nlog4j.appender.stdout.layout = org.apache.log4j.PatternLayout<br />\r\nlog4j.appender.stdout.layout.ConversionPattern = &nbsp;%d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n</p>\r\n\r\n<p>### 输出到日志文件 ###<br />\r\nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppender<br />\r\nlog4j.appender.D.File = logs/log.log<br />\r\nlog4j.appender.D.Append = true<br />\r\nlog4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志<br />\r\nlog4j.appender.D.layout = org.apache.log4j.PatternLayout<br />\r\nlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} &nbsp;[ %t:%r ] - [ %p ] &nbsp;%m%n</p>\r\n\r\n<p>### 保存异常信息到单独文件 ###<br />\r\nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppender<br />\r\nlog4j.appender.D.File = logs/error.log ## 异常日志文件名<br />\r\nlog4j.appender.D.Append = true<br />\r\nlog4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!<br />\r\nlog4j.appender.D.layout = org.apache.log4j.PatternLayout<br />\r\nlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} &nbsp;[ %t:%r ] - [ %p ] &nbsp;%m%n</p>\r\n\r\n<p>[代码中使用]&nbsp;<br />\r\n&nbsp; &nbsp;public &nbsp; class &nbsp;TestLog4j &nbsp;{<br />\r\n&nbsp; &nbsp; &nbsp;public &nbsp; static &nbsp; void &nbsp;main(String[] args) &nbsp;{<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyConfigurator.configure( &quot; D:/Code/conf/log4j.properties &quot; );<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; Logger logger &nbsp;= &nbsp;Logger.getLogger(TestLog4j. class );<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; logger.debug( &quot; debug &quot; );<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; logger.error( &quot; error &quot; );<br />\r\n&nbsp; &nbsp; }&nbsp;<br />\r\n}</p>\r\n\r\n<p>运行一下，看看异常信息是不是保存在了一个单独的文件error.log中</p>\r\n\r\n<p>log4j.properties 使用<br />\r\n一.参数意义说明<br />\r\n输出级别的种类<br />\r\nERROR、WARN、INFO、DEBUG<br />\r\nERROR 为严重错误 主要是程序的错误<br />\r\nWARN 为一般警告，比如session丢失<br />\r\nINFO 为一般要显示的信息，比如登录登出<br />\r\nDEBUG 为程序的调试信息<br />\r\n配置日志信息输出目的地<br />\r\nlog4j.appender.appenderName = fully.qualified.name.of.appender.class<br />\r\n1.org.apache.log4j.ConsoleAppender（控制台）<br />\r\n2.org.apache.log4j.FileAppender（文件）<br />\r\n3.org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）<br />\r\n4.org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）<br />\r\n5.org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）<br />\r\n配置日志信息的格式<br />\r\nlog4j.appender.appenderName.layout = fully.qualified.name.of.layout.class<br />\r\n1.org.apache.log4j.HTMLLayout（以HTML表格形式布局），<br />\r\n2.org.apache.log4j.PatternLayout（可以灵活地指定布局模式），<br />\r\n3.org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），<br />\r\n4.org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）<br />\r\n控制台选项<br />\r\nThreshold=DEBUG:指定日志消息的输出最低层次。<br />\r\nImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br />\r\nTarget=System.err：默认情况下是：System.out,指定输出控制台<br />\r\nFileAppender 选项<br />\r\nThreshold=DEBUF:指定日志消息的输出最低层次。<br />\r\nImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br />\r\nFile=mylog.txt:指定消息输出到mylog.txt文件。<br />\r\nAppend=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。<br />\r\nRollingFileAppender 选项<br />\r\nThreshold=DEBUG:指定日志消息的输出最低层次。<br />\r\nImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br />\r\nFile=mylog.txt:指定消息输出到mylog.txt文件。<br />\r\nAppend=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。<br />\r\nMaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。<br />\r\nMaxBackupIndex=2:指定可以产生的滚动文件的最大数。<br />\r\nlog4j.appender.A1.layout.ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n<br />\r\n日志信息格式中几个符号所代表的含义：<br />\r\n&nbsp;-X号: X信息输出时左对齐；<br />\r\n&nbsp;%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,<br />\r\n&nbsp;%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921<br />\r\n&nbsp;%r: 输出自应用启动到输出该log信息耗费的毫秒数<br />\r\n&nbsp;%c: 输出日志信息所属的类目，通常就是所在类的全名<br />\r\n&nbsp;%t: 输出产生该日志事件的线程名<br />\r\n&nbsp;%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10)<br />\r\n&nbsp;%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。<br />\r\n&nbsp;%%: 输出一个&quot;%&quot;字符<br />\r\n&nbsp;%F: 输出日志消息产生时所在的文件名称<br />\r\n&nbsp;%L: 输出代码中的行号<br />\r\n&nbsp;%m: 输出代码中指定的消息,产生的日志具体信息<br />\r\n&nbsp;%n: 输出一个回车换行符，Windows平台为&quot;\\r\\n&quot;，Unix平台为&quot;\\n&quot;输出日志信息换行<br />\r\n&nbsp;可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：<br />\r\n&nbsp;1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。<br />\r\n&nbsp;2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。<br />\r\n&nbsp;3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。<br />\r\n&nbsp;4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。<br />\r\n二.文件配置Sample1<br />\r\nlog4j.rootLogger=DEBUG,A1,R<br />\r\n#log4j.rootLogger=INFO,A1,R<br />\r\n# ConsoleAppender 输出<br />\r\nlog4j.appender.A1=org.apache.log4j.ConsoleAppender<br />\r\nlog4j.appender.A1.layout=org.apache.log4j.PatternLayout<br />\r\nlog4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%c]-[%p] %m%n<br />\r\n# File 输出 一天一个文件,输出路径可以定制,一般在根路径下<br />\r\nlog4j.appender.R=org.apache.log4j.DailyRollingFileAppender<br />\r\nlog4j.appender.R.File=blog_log.txt<br />\r\nlog4j.appender.R.MaxFileSize=500KB<br />\r\nlog4j.appender.R.MaxBackupIndex=10<br />\r\nlog4j.appender.R.layout=org.apache.log4j.PatternLayout<br />\r\nlog4j.appender.R.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c] [%p] - %m%n<br />\r\n文件配置Sample2<br />\r\n下面给出的Log4J配置文件实现了输出到控制台，文件，回滚文件，发送日志邮件，输出到数据库日志表，自定义标签等全套功能。<br />\r\nlog4j.rootLogger=DEBUG,CONSOLE,A1,im&nbsp;<br />\r\n#DEBUG,CONSOLE,FILE,ROLLING_FILE,MAIL,DATABASE<br />\r\nlog4j.addivity.org.apache=true<br />\r\n###################&nbsp;<br />\r\n# Console Appender&nbsp;<br />\r\n###################&nbsp;<br />\r\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender&nbsp;<br />\r\nlog4j.appender.Threshold=DEBUG&nbsp;<br />\r\nlog4j.appender.CONSOLE.Target=System.out&nbsp;<br />\r\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n&nbsp;<br />\r\n#log4j.appender.CONSOLE.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD] n%c[CATEGORY]%n%m[MESSAGE]%n%n<br />\r\n#####################&nbsp;<br />\r\n# File Appender&nbsp;<br />\r\n#####################&nbsp;<br />\r\nlog4j.appender.FILE=org.apache.log4j.FileAppender&nbsp;<br />\r\nlog4j.appender.FILE.File=file.log&nbsp;<br />\r\nlog4j.appender.FILE.Append=false&nbsp;<br />\r\nlog4j.appender.FILE.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n&nbsp;<br />\r\n# Use this layout for LogFactor 5 analysis<br />\r\n########################&nbsp;<br />\r\n# Rolling File&nbsp;<br />\r\n########################&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.Threshold=ERROR&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.File=rolling.log&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.Append=true&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.MaxFileSize=10KB&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.MaxBackupIndex=1&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n<br />\r\n####################&nbsp;<br />\r\n# Socket Appender&nbsp;<br />\r\n####################&nbsp;<br />\r\nlog4j.appender.SOCKET=org.apache.log4j.RollingFileAppender&nbsp;<br />\r\nlog4j.appender.SOCKET.RemoteHost=localhost&nbsp;<br />\r\nlog4j.appender.SOCKET.Port=5001&nbsp;<br />\r\nlog4j.appender.SOCKET.LocationInfo=true&nbsp;<br />\r\n# Set up for Log Facter 5&nbsp;<br />\r\nlog4j.appender.SOCKET.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.SOCET.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD]%n%c[CATEGORY]%n%m[MESSAGE]%n%n<br />\r\n########################&nbsp;<br />\r\n# Log Factor 5 Appender&nbsp;<br />\r\n########################&nbsp;<br />\r\nlog4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender&nbsp;<br />\r\nlog4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000<br />\r\n########################&nbsp;<br />\r\n# SMTP Appender&nbsp;<br />\r\n#######################&nbsp;<br />\r\nlog4j.appender.MAIL=org.apache.log4j.net.SMTPAppender&nbsp;<br />\r\nlog4j.appender.MAIL.Threshold=FATAL&nbsp;<br />\r\nlog4j.appender.MAIL.BufferSize=10&nbsp;<br />\r\nlog4j.appender.MAIL.From=chenyl@yeqiangwei.com<br />\r\nlog4j.appender.MAIL.SMTPHost=mail.hollycrm.com&nbsp;<br />\r\nlog4j.appender.MAIL.Subject=Log4J Message&nbsp;<br />\r\nlog4j.appender.MAIL.To=chenyl@yeqiangwei.com<br />\r\nlog4j.appender.MAIL.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.MAIL.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n<br />\r\n########################&nbsp;<br />\r\n# JDBC Appender&nbsp;<br />\r\n#######################&nbsp;<br />\r\nlog4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender&nbsp;<br />\r\nlog4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test&nbsp;<br />\r\nlog4j.appender.DATABASE.driver=com.mysql.jdbc.Driver&nbsp;<br />\r\nlog4j.appender.DATABASE.user=root&nbsp;<br />\r\nlog4j.appender.DATABASE.password=&nbsp;<br />\r\nlog4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES (&#39;[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n&#39;)&nbsp;<br />\r\nlog4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n<br />\r\nlog4j.appender.A1=org.apache.log4j.DailyRollingFileAppender&nbsp;<br />\r\nlog4j.appender.A1.File=SampleMessages.log4j&nbsp;<br />\r\nlog4j.appender.A1.DatePattern=yyyyMMdd-HH&#39;.log4j&#39;&nbsp;<br />\r\nlog4j.appender.A1.layout=org.apache.log4j.xml.XMLLayout<br />\r\n###################&nbsp;<br />\r\n#自定义Appender&nbsp;<br />\r\n###################&nbsp;<br />\r\nlog4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender<br />\r\nlog4j.appender.im.host = mail.cybercorlin.net&nbsp;<br />\r\nlog4j.appender.im.username = username&nbsp;<br />\r\nlog4j.appender.im.password = password&nbsp;<br />\r\nlog4j.appender.im.recipient = corlin@yeqiangwei.com<br />\r\nlog4j.appender.im.layout=org.apache.log4j.PatternLayout&nbsp;<br />\r\nlog4j.appender.im.layout.ConversionPattern =[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n<br />\r\n三.高级使用<br />\r\n实验目的：<br />\r\n&nbsp;1.把FATAL级错误写入2000NT日志<br />\r\n&nbsp;2. WARN，ERROR，FATAL级错误发送email通知管理员<br />\r\n&nbsp;3.其他级别的错误直接在后台输出<br />\r\n实验步骤：<br />\r\n&nbsp;输出到2000NT日志<br />\r\n&nbsp;1.把Log4j压缩包里的NTEventLogAppender.dll拷到WINNT\\SYSTEM32目录下<br />\r\n&nbsp;2.写配置文件log4j.properties<br />\r\n# 在2000系统日志输出<br />\r\n&nbsp;log4j.logger.NTlog=FATAL, A8<br />\r\n&nbsp;# APPENDER A8<br />\r\n&nbsp;log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender<br />\r\n&nbsp;log4j.appender.A8.Source=JavaTest<br />\r\n&nbsp;log4j.appender.A8.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n3.调用代码：<br />\r\n&nbsp;Logger logger2 = Logger.getLogger(&quot;NTlog&quot;); //要和配置文件中设置的名字相同<br />\r\n&nbsp;logger2.debug(&quot;debug!!!&quot;);<br />\r\n&nbsp;logger2.info(&quot;info!!!&quot;);<br />\r\n&nbsp;logger2.warn(&quot;warn!!!&quot;);<br />\r\n&nbsp;logger2.error(&quot;error!!!&quot;);<br />\r\n&nbsp;//只有这个错误才会写入2000日志<br />\r\n&nbsp;logger2.fatal(&quot;fatal!!!&quot;);<br />\r\n发送email通知管理员：<br />\r\n&nbsp;1. 首先下载JavaMail和JAF,&nbsp;<br />\r\n&nbsp; http://java.sun.com/j2ee/ja/javamail/index.html<br />\r\n&nbsp; http://java.sun.com/beans/glasgow/jaf.html<br />\r\n&nbsp;在项目中引用mail.jar和activation.jar。<br />\r\n&nbsp;2. 写配置文件<br />\r\n&nbsp;# 将日志发送到email<br />\r\n&nbsp;log4j.logger.MailLog=WARN,A5<br />\r\n&nbsp;# &nbsp;APPENDER A5<br />\r\n&nbsp;log4j.appender.A5=org.apache.log4j.net.SMTPAppender<br />\r\n&nbsp;log4j.appender.A5.BufferSize=5<br />\r\n&nbsp;log4j.appender.A5.To=chunjie@yeqiangwei.com<br />\r\n&nbsp;log4j.appender.A5.From=error@yeqiangwei.com<br />\r\n&nbsp;log4j.appender.A5.Subject=ErrorLog<br />\r\n&nbsp;log4j.appender.A5.SMTPHost=smtp.263.net<br />\r\n&nbsp;log4j.appender.A5.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n&nbsp;3.调用代码：<br />\r\n&nbsp;//把日志发送到mail<br />\r\n&nbsp;Logger logger3 = Logger.getLogger(&quot;MailLog&quot;);<br />\r\n&nbsp;logger3.warn(&quot;warn!!!&quot;);<br />\r\n&nbsp;logger3.error(&quot;error!!!&quot;);<br />\r\n&nbsp;logger3.fatal(&quot;fatal!!!&quot;);<br />\r\n在后台输出所有类别的错误：<br />\r\n&nbsp;1. 写配置文件<br />\r\n&nbsp;# 在后台输出<br />\r\n&nbsp;log4j.logger.console=DEBUG, A1<br />\r\n&nbsp;# APPENDER A1<br />\r\n&nbsp;log4j.appender.A1=org.apache.log4j.ConsoleAppender<br />\r\n&nbsp;log4j.appender.A1.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n&nbsp;2．调用代码<br />\r\n&nbsp;Logger logger1 = Logger.getLogger(&quot;console&quot;);<br />\r\n&nbsp;logger1.debug(&quot;debug!!!&quot;);<br />\r\n&nbsp;logger1.info(&quot;info!!!&quot;);<br />\r\n&nbsp;logger1.warn(&quot;warn!!!&quot;);<br />\r\n&nbsp;logger1.error(&quot;error!!!&quot;);<br />\r\n&nbsp;logger1.fatal(&quot;fatal!!!&quot;);<br />\r\n--------------------------------------------------------------------<br />\r\n&nbsp;全部配置文件：log4j.properties<br />\r\n&nbsp;# 在后台输出<br />\r\n&nbsp;log4j.logger.console=DEBUG, A1<br />\r\n&nbsp;# APPENDER A1<br />\r\n&nbsp;log4j.appender.A1=org.apache.log4j.ConsoleAppender<br />\r\n&nbsp;log4j.appender.A1.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n# 在2000系统日志输出<br />\r\n&nbsp;log4j.logger.NTlog=FATAL, A8<br />\r\n&nbsp;# APPENDER A8<br />\r\n&nbsp;log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender<br />\r\n&nbsp;log4j.appender.A8.Source=JavaTest<br />\r\n&nbsp;log4j.appender.A8.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n# 将日志发送到email<br />\r\n&nbsp;log4j.logger.MailLog=WARN,A5<br />\r\n&nbsp;# &nbsp;APPENDER A5<br />\r\n&nbsp;log4j.appender.A5=org.apache.log4j.net.SMTPAppender<br />\r\n&nbsp;log4j.appender.A5.BufferSize=5<br />\r\n&nbsp;log4j.appender.A5.To=chunjie@yeqiangwei.com<br />\r\n&nbsp;log4j.appender.A5.From=error@yeqiangwei.com<br />\r\n&nbsp;log4j.appender.A5.Subject=ErrorLog<br />\r\n&nbsp;log4j.appender.A5.SMTPHost=smtp.263.net<br />\r\n&nbsp;log4j.appender.A5.layout=org.apache.log4j.PatternLayout<br />\r\n&nbsp;log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n<br />\r\n全部代码：Log4jTest.java<br />\r\n&nbsp;&nbsp;<br />\r\n/*&nbsp;<br />\r\n&nbsp; * 创建日期 2003-11-13&nbsp;<br />\r\n&nbsp; */&nbsp;<br />\r\n&nbsp;package edu.bcu.Bean;&nbsp;<br />\r\n&nbsp;import org.apache.log4j.*;&nbsp;<br />\r\n&nbsp;//import org.apache.log4j.nt.*;&nbsp;<br />\r\n&nbsp;//import org.apache.log4j.net.*;&nbsp;<br />\r\n&nbsp;/**&nbsp;<br />\r\n&nbsp; * @author yanxu&nbsp;<br />\r\n&nbsp; */&nbsp;<br />\r\n&nbsp;public class Log4jTest&nbsp;<br />\r\n&nbsp;{&nbsp;<br />\r\n&nbsp; public static void main(String args[])&nbsp;<br />\r\n&nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp;PropertyConfigurator.configure(&quot;log4j.properties&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;//在后台输出&nbsp;<br />\r\n&nbsp; &nbsp;Logger logger1 = Logger.getLogger(&quot;console&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger1.debug(&quot;debug!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger1.info(&quot;info!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger1.warn(&quot;warn!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger1.error(&quot;error!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger1.fatal(&quot;fatal!!!&quot;);<br />\r\n//在NT系统日志输出&nbsp;<br />\r\n&nbsp; &nbsp;Logger logger2 = Logger.getLogger(&quot;NTlog&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;//NTEventLogAppender nla = new NTEventLogAppender();&nbsp;<br />\r\n&nbsp; &nbsp;logger2.debug(&quot;debug!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger2.info(&quot;info!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger2.warn(&quot;warn!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger2.error(&quot;error!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;//只有这个错误才会写入2000日志&nbsp;<br />\r\n&nbsp; &nbsp;logger2.fatal(&quot;fatal!!!&quot;);<br />\r\n//把日志发送到mail&nbsp;<br />\r\n&nbsp; &nbsp;Logger logger3 = Logger.getLogger(&quot;MailLog&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;//SMTPAppender sa = new SMTPAppender();&nbsp;<br />\r\n&nbsp; &nbsp;logger3.warn(&quot;warn!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger3.error(&quot;error!!!&quot;);&nbsp;<br />\r\n&nbsp; &nbsp;logger3.fatal(&quot;fatal!!!&quot;);&nbsp;<br />\r\n&nbsp; }&nbsp;<br />\r\n&nbsp;}</p>\r\n',6,'孟祥坤','10a23595-0918-4e1d-b455-c507283eb179.jpg'),(52,'other','Docker的安装及使用','2017-08-19 12:01:40','2017-08-19 12:02:47','第一个Docker化的Java应用','<h2>什么是Docker：</h2>\r\n\r\n<p style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">◇Docker is the world&#39;s leading software containerization platform&nbsp;</p>\r\n\r\n<p style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">◇Docker公司开发，开源，托管在GitHub。</p>\r\n\r\n<p style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">◇跨平台，支持Linux、Windows、MacOS。</p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>Docker思想：</h2>\r\n\r\n<p><img alt=\"\" src=\"/userImg/ArticlePic?fileName=222b1448-85e2-402c-a7f1-f64c6cb00983.png\" style=\"height:225px; width:400px\" /></p>\r\n\r\n<h2>Docker镜像存储方式：</h2>\r\n\r\n<p><img alt=\"\" src=\"/userImg/ArticlePic?fileName=e6a5e777-ce8f-4864-b964-370bf7428867.png\" style=\"height:275px; width:362px\" /></p>\r\n\r\n<p>最上方是可读写的，其余都是只读的，当容器要修改Image内容时，会将镜像拷到最上层进行修改，读文件时从最上方开始查找，镜像文件只读保证了同一个镜像可建立多个容器。</p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>Docker仓库：</h2>\r\n\r\n<p>◇官方仓库：hub.docker.com</p>\r\n\r\n<p>◇网易蜂巢：c.163.com</p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>Linux下Docker的安装：</h2>\r\n\r\n<p>◇Redhat&amp;CentOS：</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;系统要求：64-bit OS and version 3.10</p>\r\n\r\n<p>◇Ubuntu</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;系统要求：64-bit OS and version 3.10</p>\r\n\r\n<p>uname -r 查看系统内核版本</p>\r\n\r\n<p>apt安装：sudo apt install -y docker.io</p>\r\n\r\n<p>curl安装: curl -s https://get.docker.com|sh</p>\r\n\r\n<p>查看Docker版本：docker -version</p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>第一个Docker镜像：</h2>\r\n\r\n<p>◇拉取镜像：docker pull [OPTIONS] NAME[:TAG]</p>\r\n\r\n<p>◇查看镜像：docker images [OPTIONS] [REPOSITORY[:TAG]]</p>\r\n\r\n<p>不加：TAG标签默认为最新版本</p>\r\n\r\n<p>◇运行镜像：docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...]</p>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">拉取过程示意图：</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\"><img alt=\"\" src=\"/userImg/ArticlePic?fileName=68f17a5d-2e3e-4a85-b640-c74e1fc8b07b.png\" style=\"height:317px; width:600px\" /></div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>运行Nginx镜像：</h2>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">特性：</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">&nbsp; &nbsp; &nbsp; ◇持久运行的容器</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">&nbsp; &nbsp; &nbsp; ◇前台挂起&amp;后台运行</div>\r\n\r\n<div style=\"background:#eeeeee; border:1px solid #cccccc; padding:5px 10px\">&nbsp; &nbsp; &nbsp; ◇进入容器内部</div>\r\n\r\n<p>查看帮助信息：docker run --help</p>\r\n\r\n<p>后台运行Nginx：docker run -d hub.c.163.com/libary/nginx</p>\r\n\r\n<p>进入容器内部：docker exec -it f4 bash&nbsp;</p>\r\n\r\n<h3>Docker网络：</h3>\r\n\r\n<p>◇网络类型： Bridge &nbsp; &nbsp;Host &nbsp; &nbsp;None</p>\r\n\r\n<p><img alt=\"\" src=\"/userImg/ArticlePic?fileName=d8aafadc-1ba4-419a-a1bb-1bcc471ba3c6.png\" style=\"height:272px; width:550px\" /></p>\r\n\r\n<p>◇端口映射： &nbsp;docker run -d -p [主机端口]:[容器端口] IMAGE</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; docker -d -P 映射容器上所有端口</p>\r\n\r\n<h2>制作自己的镜像：</h2>\r\n\r\n<p>◇Dockerfile</p>\r\n\r\n<p>◇docker buile</p>\r\n\r\n<p>◇自己的WEB应用</p>\r\n\r\n<p>1.Dokcerfile的配置：</p>\r\n\r\n<p>from hub.c.163.com/libary/tomcat</p>\r\n\r\n<p>MAINTAINER 联系信息</p>\r\n\r\n<p>COPY ***.war /usr/lcoal/tomcat/webapps</p>\r\n\r\n<p>2.docker build</p>\r\n\r\n<p>执行docker build .</p>\r\n\r\n<p>3.运行自己的Docker应用</p>\r\n\r\n<p>docker run -d -p [port]:[port] webname</p>\r\n\r\n<p>注意：不同容器之间的访问要设置为本机的IP地址，Localhost是相对于容器本身的。</p>\r\n',13,'孟祥坤','6a818aa8-b4bf-4462-aed6-94fbffe19426.png'),(59,'java','Spring Boot 基础教程','2017-08-19 18:07:20',NULL,'转载自http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/','<p>转载自<a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B\">点这里</a></p>\r\n',9,'孟祥坤','220c866c-289f-4eaa-9ac9-e68ea5bf9017.png'),(60,'other','Nginx端口转发（反向代理）','2017-08-21 18:56:37',NULL,'我们将介绍 Nginx 的 Http 代理功能（它允许 Nignx 传递请求到后端服务器，进行后续处理）。Nginx 经常被设置成反向代理帮助横向拓展设施提升负载能力或者传递请求给其他服务器。  接下来，我们将讨论如何使用 Nginx 的负载均衡功能来横向拓展（scale out）服务器。我们同样也探讨使用缓存来提升代理的性能。','<h2 style=\"text-align:justify\">常规的代理信息（重点校对）</h2>\r\n\r\n<p style=\"text-align:justify\">如果你过去只是在简单场景下使用 <strong>Web</strong> 服务器，单台服务器配置，那你可能会怀疑为什么需要代理请求。</p>\r\n\r\n<p style=\"text-align:justify\">使用代理的其中一个理由是横向拓展提升你基础设施。<strong>Nignx</strong> 本来被用来处理并发请求，使它成为客户端接触点的理想选择。这个服务器可以传递请求给任何数量的后端服务器，来处理处理大量任务，达到夸设备拓展负载的目的。这个设计同样也帮助你更容易的增加服务器或者下线需要维护的服务器。</p>\r\n\r\n<p style=\"text-align:justify\">另外一个例子就是当使用应用服务器，该应用本身不能直接处理从客户端传递过来请求时，代理服务器同样有用。很多框架（包括 <strong>Web</strong> 服务器）不如专门设计成高性能服务（如 <strong>Nignx</strong>）健壮。把 <strong>Nginx</strong> 放在这些服务之前，可以提升用户体验和安全性。</p>\r\n\r\n<p style=\"text-align:justify\"><strong>Nigix</strong> 通过接收一个请求，把它转发传递给其他服务器完成来完成代理。请求的结果会传递回 <strong>Nginx</strong>，展示给客户端。实例中的其他服务器可以是远端机器，本地服务，甚至是由 <strong>Nginx</strong> 定义的其他虚拟服务。<strong>Nginx</strong> 代理处理请求的服务器，我们称之为<strong>upstream</strong>（上游）服务。</p>\r\n\r\n<p style=\"text-align:justify\"><strong>Nginx</strong> 可以代理使用 <strong>http(s)</strong>, <strong>FastCGI</strong>, <strong>SCGI</strong> 和 <strong>uwsgi</strong> 的请求，或者为每种代理制定不同指令进行多级缓存协议。<strong>Nginx</strong> 实例负责传递请求，并把各个信息组件揉成一个 <strong>upstream</strong> 可理解的格式。</p>\r\n\r\n<h2 style=\"text-align:justify\">解构简单的 HTTP Proxy Pass</h2>\r\n\r\n<p style=\"text-align:justify\">最简单的代理类型莫过于把一个请求导向到单一可使用 <strong>http</strong> 协议通信的服务器。这种代理类型我们统称为 <strong>proxy pass</strong>，由 <code>proxy_pass</code> 同名 <strong>Nginx</strong> 指令处理。</p>\r\n\r\n<p style=\"text-align:justify\"><code>proxy_pass</code> 指令主要在地址（<code>Location</code>）语境中被看到。它同样在 <code>Location</code> 和 <code>limit_except</code> 语境下的 <code>if</code> 语法块中有效。当一个请求匹配到一个包含 <code>proxy_pass</code> 的 <code>Location</code>时，这个请求将会被指令转发（Forward）到这个链接去。</p>\r\n\r\n<p style=\"text-align:justify\">让我们看一个例子：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">在上面代码片段中，<code>proxy_pass</code> 定义中的服务器没有提供 <strong>URI</strong>。这个模式的定义，请求的 <strong>URI</strong> 会原封不动地直接传递给 <strong>upstream</strong> 服务器。</p>\r\n\r\n<p style=\"text-align:justify\">例如，当一个匹配 <code>/match/here/please</code> 的请求被这个 <strong>block</strong> 处理，这个请求将会以 <em>http://example.com/match/here/please</em> 的形式把 URI 发送给 <code>example.com</code> 服务器。</p>\r\n\r\n<p style=\"text-align:justify\">让我们一起看看另外一个场景：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述例子中，代理服务器在尾部定义了 <strong>URI</strong> 部分。当 <strong>URI</strong> 放到 <code>proxy_pass</code> 定义中，请求中匹配这个 <code>Location</code> 的定义的部分在传递的过程中将会被这个 <strong>URI</strong> 替换掉。</p>\r\n\r\n<p style=\"text-align:justify\">例如，一个匹配 <code>/match/here/please</code> 的请求将会以 <em>http://example.com/new/prefix/please</em> 的形式发送给 <strong>upsream</strong> 服务器。<code>/match/here</code> 将会替换成 <code>/new/prefix</code>。这一点很重要，必须记住。</p>\r\n\r\n<p style=\"text-align:justify\">有时，这样的替换是不可完成的。这时，定义在 <code>proxy_pass</code> 的尾部的<strong>URI</strong> 会被忽略，<strong>Nginx</strong> 直接把来自客户端或被其他 <strong>Nginx</strong> 的指令修改的 <strong>URI</strong> 传递给 <strong>upstream</strong> 服务器。</p>\r\n\r\n<p style=\"text-align:justify\">例如，使用正则表达式匹配 <strong>Location</strong> 时，<strong>Nginx</strong> 不能决定 <strong>URI</strong> 的哪一个部分匹配这个表达式，于是它直接发送客户端请求的原始 <strong>URI</strong>。还有另一个例子，当一个 <strong>rewrite</strong> 指令在同一个地址中使用，会导致客户端的 <strong>URI</strong> 被重写，但是仍然在同一个 <strong>block</strong> 下处理，这时，重写的 <strong>URI</strong> 会被传递。</p>\r\n\r\n<h2 style=\"text-align:justify\">理解 Nginx 处理 Headers 的方式</h2>\r\n\r\n<p style=\"text-align:justify\">有一件事情可能现在不会马上明白，如果你希望 <strong>upstream</strong> 服务合理地处理请求，那仅仅传递 <strong>URI</strong>是不够的。来自于 <strong>Nginx</strong> 请求不同于直接来源于客户端的请求。这里的差异最大的一部分就是请求的 <strong>Headers</strong> 信息。</p>\r\n\r\n<p style=\"text-align:justify\">当 <strong>Nginx</strong> 代理一个请求，它会自动对 <strong>Headers</strong> 信息做一些调整：</p>\r\n\r\n<ul>\r\n	<li style=\"text-align: justify;\"><strong>Nginx</strong> 去除任何空的 <strong>Headers</strong>。传递空值到其他服务器是没有意义的；它只会让请求变得臃肿。</li>\r\n	<li style=\"text-align: justify;\"><strong>Nginx</strong> 默认把包含下划线的 <strong>Headers</strong> 信息视为无效，会被移除。如果你希望把这样的信息解释为有效，你可以把 <code>underscores_in_headers</code> 执行设置成 <code>on</code>，否则你的头信息将永远不会把他发送给后端服务器。</li>\r\n	<li style=\"text-align: justify;\"><code>Host</code> 会被重写成由 <code>$proxy_host</code> 定义的值。它可以是 <code>IP</code> （或者名称）和端口，直接由 <code>proxy_pass</code> 指令定义的。</li>\r\n	<li style=\"text-align: justify;\">头信息 <strong>Connection</strong> 改成 <code>close</code>。这个 <strong>Header</strong> 用在关于两个服务器创建特定链接的信号信号。在这个实例中，<strong>Nginx</strong> 把它设置成 <code>close</code> 来指定一旦原始请求被响应，<strong>upstream</strong> 服务的这个连接将被关闭。<strong>upstream</strong> 服务器不应该期待这个连接被持久化。</li>\r\n</ul>\r\n\r\n<p style=\"text-align:justify\">从第一点看来，我们可以确定任何你不想要传递的头信息应该被设置成空字符串。带空值的头信息会被完全删除掉。</p>\r\n\r\n<p style=\"text-align:justify\">接下来一点用来设置如果你的后端应用想要接受非标准的头，你应该确保它们不应该带下划线。如果你需要的头信息使用下划线，你可以在你的配置后面，把 <code>underscores_in_headers </code> 设置成 <code>on</code>（在 <strong>http</strong> 上下文或者为这个 IP/端口组合声明的默认服务器上下文红中有效）。如果你不想这么做，<strong>Nginx</strong> 将会把这个头标记为无效，并在传递给 <strong>upstream</strong> 服务器之前把它丢弃。</p>\r\n\r\n<p style=\"text-align:justify\">头信息 <strong>Host</strong> 在大部分代理场景中起着重要作用。和之前讲的一样，默认，它会被设置成 <code>$proxy_host</code> 的值，一个由 <code>proxy_pass</code> 定义的包含域名或者 IP 以及端口的值。这样的默认设定是为了让 <strong>Nginx</strong> 确保 <strong>upsteam</strong> 服务器可以响应的唯一的地址（它直接从连接信息取出的）。</p>\r\n\r\n<p style=\"text-align:justify\"><code>Host</code> 常见的值如下：</p>\r\n\r\n<ul>\r\n	<li style=\"text-align: justify;\"><code>$proxy_host</code>：它把 <strong>Host</strong> 头设置成从 <code>proxy_pass</code> 定义的域名或IP加上端口的组合。从 <strong>Nginx</strong> 的角度看，它是默认以及安全的，但是经常不是被代理服务器需要的来正确处理请求的值。</li>\r\n	<li style=\"text-align: justify;\"><code>$http_host</code>：它把 <strong>Host</strong> 头设置成从和直接从客户端请求的一样。这个头由客户端发送，可以被 <strong>Nginx</strong> 使用。这个变量名前缀是 <code>$http_</code>，后面跟着头信息的名称，以小写命名，任何斜杠都会被下划线替换。虽然 <code>$http_host</code> 在大部分情况可用的，但是当客户端请求没有有效的 <strong>Host</strong> 信息的时候，会导致传输失败。</li>\r\n	<li style=\"text-align: justify;\"><code>$host</code>：这个是偏好是指：可以是来自请求的主机名，请求中的 <strong>Host</strong> 头信息或者匹配请求的服务器名。</li>\r\n</ul>\r\n\r\n<p style=\"text-align:justify\">在大部分情况，你将会把 <strong>Host</strong> 头信息设置成 <code>$host</code> 变量。它是最灵活的，经常为被代理的服务器提供尽可能精确的 <strong>Host</strong> 头信息。</p>\r\n\r\n<h2 style=\"text-align:justify\">设置或者重置 Header</h2>\r\n\r\n<p style=\"text-align:justify\">为了适配代理连接，我们使用 <code>proxy_set_header</code> 指令。例如，为了改变我们之前讨论的 <strong>Host</strong> 头信息，并增加一些其它的和代理请求一样的 <strong>Header</strong>，我们可以这么做：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_set_header HOST $host;\r\n    proxy_set_header X-Forwarded-Proto $scheme;\r\n    proxy_set_header X-Real-IP $remote_addr;\r\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述请求把 <strong>Host</strong> 头设置成 <code>$host</code> 变量，它讲包含请求的原始 <code>host</code>。<code>X-Forwarded-Proto</code> 头信息提供了关于院士客户端请求模式的被代理服务器信息（决定 <strong>http</strong> 还是 <strong>https</strong> 请求）。</p>\r\n\r\n<p style=\"text-align:justify\"><code>X-Real-IP</code> 被设置成客户端的 IP 地址，以便代理服务器做判定或者记录基于该信息的日志。<code>X-Forwarded-For</code> 头信息是一个包含整个代理过程经过的所有服务器 IP 地址的列表。在上述例子中，我们把它设置成 <code>$proxy_add_x_forwarded_for</code> 变量。这个变量包含了从客户端获取的 <code>X-Forwarded-For</code> 头信息并把 <strong>Nginx</strong> 服务器的 IP 添加到最后。</p>\r\n\r\n<p style=\"text-align:justify\">当然，我们会把 <code>proxy_set_header</code> 指令移到服务器或者 <strong>http</strong> 上下文的外部，允许它同时在多个 <code>Location</code> 生效：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># server context\r\n\r\nproxy_set_header HOST $host;\r\nproxy_set_header X-Forwarded-Proto $scheme;\r\nproxy_set_Header X-Real-IP $remote_addr;\r\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\nlocation /different/match {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n</div>\r\n\r\n<h2 style=\"text-align:justify\">为负载均衡代理服务器定义 Upstream 上下文</h2>\r\n\r\n<p style=\"text-align:justify\">在上一个例子中，我们演示了如何实现为了一个单一后端服务器做简单的 <strong>Http</strong> 代理。<strong>Nginx</strong> 帮助我们很容易通过指定一个后端服务器集群池子来扩展这个配置。</p>\r\n\r\n<p style=\"text-align:justify\">我们使用 <code>upstream</code> 指令来定义服务器群的池子（pool）。这个配置假设这个服务器列表中的每台机子都可以处理来自客户端的请求。它允许我们轻轻松松横向扩展我们的基础设施。<code>upstream</code> 指令必须在 <strong>Nginx</strong> 的 <code>http</code> 上下文中设置。</p>\r\n\r\n<p style=\"text-align:justify\">让我们一起看个简单的例子：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    server_name example.com;\r\n\r\n    location /proxy-me {\r\n        proxy_pass http://backend_hosts;\r\n    }\r\n}\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述例子，我们设置一个叫做 <code>backend_hosts</code> 的 <strong>upstream</strong> 上下文。一旦定义了，这个名称可以直接在 <code>proxy_pass</code> 中使用，就和常规的域名一样。如你所见，在我们的服务器块内，所有指向 <em>example.com/proxy-me/&hellip;</em> 的请求都会被传递到我们定义的池子中。在那个池子内，会根据配置算法选取一个服务器。默认，它只是一个简单的循环选择处理（每一个请求都会按顺序传递给不同的服务器）。</p>\r\n\r\n<h3 style=\"text-align:justify\">改变 Upstream 均衡算法</h3>\r\n\r\n<p style=\"text-align:justify\">你可以通过指令或者标志修改 <strong>upstream</strong> 池子的均衡算法：</p>\r\n\r\n<ul>\r\n	<li style=\"text-align: justify;\"><strong>（轮询 Round Robin）</strong>：默认的负载均衡算法，如果没有其它算法被指定的话，它会被使用。<strong>upstream</strong> 上下文定义的每一个服务器都会按顺序接受请求。</li>\r\n	<li style=\"text-align: justify;\"><strong>最少连接 least_conn</strong>: 指定新的连接永远应该传递给拥有最少连接的后端服务器。这个算法在后端连接有时候需要持久化的情况下将很有效。</li>\r\n	<li style=\"text-align: justify;\"><strong>ip 哈希 ip_hash</strong>：这种均衡算法基于客户端的 IP 分发到不同的服务器。把客户端 IP的前三位八进制数作为键值来决定服务器处理哪个请求。这样结果是，客户端每次由同一个台服务器服务，它能保证回话的一致性。</li>\r\n	<li style=\"text-align: justify;\"><strong>哈希 hash</strong>：这类均衡算法主要运用于缓存代理。服务器是给予提供的哈希值来分隔的。它可以是文本，变量或者文本变量组合。</li>\r\n</ul>\r\n\r\n<p style=\"text-align:justify\">修改均衡算法，应该像下面那样：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n\r\n    least_conn;\r\n\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述例子中，最少连接数的服务器将会优先选择。<code>ip_hash</code> 指令也可以用同样的方式设置，来获取同样数量的会话粘性。</p>\r\n\r\n<p style=\"text-align:justify\">至于 <code>hash</code> 方法，你应该提供要哈希的键。可以是任何你想要的：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n\r\n    hash $remote_addr$remote_port consistent;\r\n\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述的例子，请求分发是基于客户端的 ip 和端口。我们也可以添加另外的参数 <code>consistent</code>，它实现了 Ketama 一致性 Hash 算法。基本上，它意味着如果你的 <strong>upstream</strong> 服务器改变了， 保证对 cache 的最小印象。</p>\r\n\r\n<h3 style=\"text-align:justify\">设置服务器权重</h3>\r\n\r\n<p style=\"text-align:justify\">在后端服务器声明中，每一台的服务器默认是权重平分的。它假定每一台服务器都能也都应该处理同一量级的负载（考虑到负载均衡算法的影响）。然而，你也可以为服务器设置其它的权重。</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n    server host1.example.com weight=3;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">上述例子中，<code>host1.example.com</code> 可以比其它服务器多接受 2 倍的流量。默认，每一台服务器的权重都是 1。</p>\r\n\r\n<h2 style=\"text-align:justify\">使用 Buffer 缓解后端服务器的负载</h2>\r\n\r\n<p style=\"text-align:justify\">对于大部分使用代理的用户最关心的一件事情就是添加一台服务器对性能的影响。大部分场景下，利用 <strong>Nginx</strong> 的缓冲和缓存能力，可以大大地减轻负担。</p>\r\n\r\n<p style=\"text-align:justify\">当代理到其它服务器是，两个不同连接的速度影响客户端的体验：</p>\r\n\r\n<ul>\r\n	<li style=\"text-align: justify;\">从客户端到代理服务器的连接</li>\r\n	<li style=\"text-align: justify;\">从代理服务器到后端服务器的连接</li>\r\n</ul>\r\n\r\n<p style=\"text-align:justify\"><strong>Nginx</strong> 可以根据你想要优化哪一个连接来调整它的行为。</p>\r\n\r\n<p style=\"text-align:justify\">没有缓冲（<strong>buffer</strong>），数据将会直接从代理服务器传输到客户端。如果客户端的速度足够快（假设），<strong>buffer</strong> 可以关掉让数据尽可能快速地到达。如果使用 <strong>buffer</strong>，<strong>Nginx</strong> 代理服务器将会临时存储后端响应，然后慢慢把数据喂给客户端。如果客户端很慢，它可以让 <strong>Nginx</strong> 提前关闭后端服务器的连接。它可以控制在哪一步处理分发数据给客户端。</p>\r\n\r\n<p style=\"text-align:justify\"><strong>Nginx</strong> 默认的缓冲设计是客户端有这千差万别的速度。我们可以使用如下指令来调整缓冲速度。你可以把 <strong>buffer</strong> 设置防盗 <code>http</code>，<code>server</code> 或者 <code>location</code> 上下文中。必须记住指令为每一个请求配置的大小，因此如果客户端的请求很多，把值调的过大，会很影响性能：</p>\r\n\r\n<ul>\r\n	<li style=\"text-align: justify;\"><code>porxy_buffering</code>：这个指令控制所在上下文或者子上下文的<strong>buffer</strong>是否打开。默认是 <code>on</code>。</li>\r\n	<li style=\"text-align: justify;\"><code>proxy_buffers</code>：这个指令控制 <strong>buffer</strong> 的数量（第一个参数）和大小（第二个参数）。默认是 8 个 <strong>buffer</strong>，每个 <strong>buffer</strong> 大小是 1 个内存页（4k 或 8k）。增加 <strong>buffer</strong> 的数量可以缓冲更多的信息。</li>\r\n	<li style=\"text-align: justify;\"><code>proxy_buffer_size</code>：是来自后端服务器响应信息的一部分，它包含头信息，从响应的部分分离出来。这个指令设置响应部分的缓冲。默认，它和 <code>proxy_buffers</code> 一样，但是因为它仅用于头信息，所有它市场被设置成更低的值。</li>\r\n	<li style=\"text-align: justify;\"><code>proxy_busy_buffer_size</code>：这个指令设置忙时 <strong>buffer</strong> 的最大值。一个客户端一次只能从一个 <strong>buffer</strong> 读取数据的同时，<strong>buffer</strong> 会被放到队列中，等待发送到客户端。这个指令控制在这个状态下 <strong>buffer</strong> 的空间大小</li>\r\n	<li style=\"text-align: justify;\"><code>proxy_max_temp_file_size</code>：这个是 <strong>Nginx</strong> 一次可以写临时文件的最大数据量，当代理服务器的响应太大超出配置的 <strong>buffer</strong> 的时候。</li>\r\n	<li style=\"text-align: justify;\"><code>proxy_temp_path</code>：当代理服务器的响应太大超出配置的 <strong>buffer</strong> 的时候，<strong>Nginx</strong> 写临时文件的路径。</li>\r\n</ul>\r\n\r\n<p style=\"text-align:justify\">正如你看到的，<strong>Nginx</strong> 提供了很少指令来调整缓冲行为。大部分时间，你不需要关心大部分指令，但是它们中的一些会很有用。可能最有用的就是 <code>proxy_buffer</code> 和 <code>proxy_buffer_size</code> 这两个指令。</p>\r\n\r\n<p style=\"text-align:justify\">下面这个例子中睁开每个 <strong>upstream</strong> 可用代理 <strong>buffer</strong> 数，减少存储头信息的 <strong>buffer</strong> 数：</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre>\r\n<code># server context\r\n\r\nproxy_buffering on;\r\nproxy_buffer_size 1k;\r\nproxy_buffers 24 4k;\r\nproxy_busy_buffers_size 8k;\r\nproxy_max_temp_file_size 2048m;\r\nproxy_temp_file_write_size 32k;\r\n\r\nlocation / {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n</div>\r\n\r\n<p style=\"text-align:justify\">相反，如果你的客户端足够快到你可以直接传输数据，你就可以完全关掉 <strong>buffer</strong>。实际上，即使 <strong>upstream</strong> 比客户端快很多，<strong>Nginx</strong> 还是会使用 <strong>buffer</strong> 的，但是它会直接清空到客户端的数据，不会让它进入到池子。如果客户端很慢，这会导致 <strong>upstream</strong> 连接会一直开到客户端赶上为止。当缓冲被设置为 <code>off</code> 的时候，只有 <code>proxy_buffer_size</code> 指令定义的 <strong>buffer</strong> 会被使用。</p>\r\n\r\n<div class=\"highlighter-rouge\">\r\n<pre style=\"text-align:justify\">\r\n<code># server context\r\n\r\nproxy_buffering off;\r\nproxy_buffer_size 4k;\r\n\r\nlocation / {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n</div>\r\n',7,'孟祥坤','4fdbc2a3-5077-4e7a-a02e-91a46cc77879.png'),(61,'other','nginx配置location总结及rewrite规则写法','2017-08-21 19:01:17',NULL,'转载自：http://seanlook.com/2015/05/17/nginx-location-rewrite/','<h1>1. location正则写法</h1>\r\n\r\n<p>一个示例：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">1</div>\r\n\r\n			<div class=\"line\">2</div>\r\n\r\n			<div class=\"line\">3</div>\r\n\r\n			<div class=\"line\">4</div>\r\n\r\n			<div class=\"line\">5</div>\r\n\r\n			<div class=\"line\">6</div>\r\n\r\n			<div class=\"line\">7</div>\r\n\r\n			<div class=\"line\">8</div>\r\n\r\n			<div class=\"line\">9</div>\r\n\r\n			<div class=\"line\">10</div>\r\n\r\n			<div class=\"line\">11</div>\r\n\r\n			<div class=\"line\">12</div>\r\n\r\n			<div class=\"line\">13</div>\r\n\r\n			<div class=\"line\">14</div>\r\n\r\n			<div class=\"line\">15</div>\r\n\r\n			<div class=\"line\">16</div>\r\n\r\n			<div class=\"line\">17</div>\r\n\r\n			<div class=\"line\">18</div>\r\n\r\n			<div class=\"line\">19</div>\r\n\r\n			<div class=\"line\">20</div>\r\n\r\n			<div class=\"line\">21</div>\r\n\r\n			<div class=\"line\">22</div>\r\n\r\n			<div class=\"line\">23</div>\r\n\r\n			<div class=\"line\">24</div>\r\n\r\n			<div class=\"line\">25</div>\r\n\r\n			<div class=\"line\">26</div>\r\n\r\n			<div class=\"line\">27</div>\r\n\r\n			<div class=\"line\">28</div>\r\n\r\n			<div class=\"line\">29</div>\r\n\r\n			<div class=\"line\">30</div>\r\n\r\n			<div class=\"line\">31</div>\r\n\r\n			<div class=\"line\">32</div>\r\n\r\n			<div class=\"line\">33</div>\r\n\r\n			<div class=\"line\">34</div>\r\n\r\n			<div class=\"line\">35</div>\r\n\r\n			<div class=\"line\">36</div>\r\n\r\n			<div class=\"line\">37</div>\r\n\r\n			<div class=\"line\">38</div>\r\n\r\n			<div class=\"line\">39</div>\r\n\r\n			<div class=\"line\">40</div>\r\n\r\n			<div class=\"line\">41</div>\r\n\r\n			<div class=\"line\">42</div>\r\n\r\n			<div class=\"line\">43</div>\r\n\r\n			<div class=\"line\">44</div>\r\n\r\n			<div class=\"line\">45</div>\r\n\r\n			<div class=\"line\">46</div>\r\n\r\n			<div class=\"line\">47</div>\r\n\r\n			<div class=\"line\">48</div>\r\n\r\n			<div class=\"line\">49</div>\r\n\r\n			<div class=\"line\">50</div>\r\n\r\n			<div class=\"line\">51</div>\r\n			</td>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">location = / {</div>\r\n\r\n			<div class=\"line\"># 精确匹配 / ，主机名后面不能带任何字符串</div>\r\n\r\n			<div class=\"line\">[ configuration A ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location / {</div>\r\n\r\n			<div class=\"line\"># 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</div>\r\n\r\n			<div class=\"line\"># 但是正则和最长字符串会优先匹配</div>\r\n\r\n			<div class=\"line\">[ configuration B ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location /documents/ {</div>\r\n\r\n			<div class=\"line\"># 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</div>\r\n\r\n			<div class=\"line\"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</div>\r\n\r\n			<div class=\"line\">[ configuration C ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ~ /documents/Abc {</div>\r\n\r\n			<div class=\"line\"># 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索</div>\r\n\r\n			<div class=\"line\"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</div>\r\n\r\n			<div class=\"line\">[ configuration CC ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ^~ /images/ {</div>\r\n\r\n			<div class=\"line\"># 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</div>\r\n\r\n			<div class=\"line\">[ configuration D ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ~* \\.(gif|jpg|jpeg)$ {</div>\r\n\r\n			<div class=\"line\"># 匹配所有以 gif,jpg或jpeg 结尾的请求</div>\r\n\r\n			<div class=\"line\"># 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</div>\r\n\r\n			<div class=\"line\">[ configuration E ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location /images/ {</div>\r\n\r\n			<div class=\"line\"># 字符匹配到 /images/，继续往下，会发现 ^~ 存在</div>\r\n\r\n			<div class=\"line\">[ configuration F ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location /images/abc {</div>\r\n\r\n			<div class=\"line\"># 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</div>\r\n\r\n			<div class=\"line\"># F与G的放置顺序是没有关系的</div>\r\n\r\n			<div class=\"line\">[ configuration G ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ~ /images/abc/ {</div>\r\n\r\n			<div class=\"line\"># 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</div>\r\n\r\n			<div class=\"line\">[ configuration H ]</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ~* /js/.*/\\.js</div>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>已<code>=</code>开头表示精确匹配<br />\r\n	如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。</li>\r\n	<li><code>^~</code> 开头表示uri以某个常规字符串开头，不是正则匹配</li>\r\n	<li>~ 开头表示区分大小写的正则匹配;</li>\r\n	<li>~* 开头表示不区分大小写的正则匹配</li>\r\n	<li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到</li>\r\n</ul>\r\n\r\n<p>顺序 no优先级：<br />\r\n(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>\r\n\r\n<p>上面的匹配结果<br />\r\n按照上面的location写法，以下的匹配示例成立：</p>\r\n\r\n<ul>\r\n	<li>/ -&gt; config A<br />\r\n	精确完全匹配，即使/index.html也匹配不了</li>\r\n	<li>/downloads/download.html -&gt; config B<br />\r\n	匹配B以后，往下没有任何匹配，采用B</li>\r\n	<li>/images/1.gif -&gt; configuration D<br />\r\n	匹配到F，往下匹配到D，停止往下</li>\r\n	<li>/images/abc/def -&gt; config D<br />\r\n	最长匹配到G，往下匹配D，停止往下<br />\r\n	你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序</li>\r\n	<li>/documents/document.html -&gt; config C<br />\r\n	匹配到C，往下没有任何匹配，采用C</li>\r\n	<li>/documents/1.jpg -&gt; configuration E<br />\r\n	匹配到C，往下正则匹配到E</li>\r\n	<li>/documents/Abc.jpg -&gt; config CC<br />\r\n	最长匹配到C，往下正则顺序匹配到CC，不会往下到E</li>\r\n</ul>\r\n\r\n<h2>实际使用建议</h2>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">1</div>\r\n\r\n			<div class=\"line\">2</div>\r\n\r\n			<div class=\"line\">3</div>\r\n\r\n			<div class=\"line\">4</div>\r\n\r\n			<div class=\"line\">5</div>\r\n\r\n			<div class=\"line\">6</div>\r\n\r\n			<div class=\"line\">7</div>\r\n\r\n			<div class=\"line\">8</div>\r\n\r\n			<div class=\"line\">9</div>\r\n\r\n			<div class=\"line\">10</div>\r\n\r\n			<div class=\"line\">11</div>\r\n\r\n			<div class=\"line\">12</div>\r\n\r\n			<div class=\"line\">13</div>\r\n\r\n			<div class=\"line\">14</div>\r\n\r\n			<div class=\"line\">15</div>\r\n\r\n			<div class=\"line\">16</div>\r\n\r\n			<div class=\"line\">17</div>\r\n\r\n			<div class=\"line\">18</div>\r\n\r\n			<div class=\"line\">19</div>\r\n\r\n			<div class=\"line\">20</div>\r\n\r\n			<div class=\"line\">21</div>\r\n			</td>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</div>\r\n\r\n			<div class=\"line\">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</div>\r\n\r\n			<div class=\"line\">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</div>\r\n\r\n			<div class=\"line\"># 第一个必选规则</div>\r\n\r\n			<div class=\"line\">location = / {</div>\r\n\r\n			<div class=\"line\">proxy_pass http://tomcat:8080/index</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</div>\r\n\r\n			<div class=\"line\"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</div>\r\n\r\n			<div class=\"line\">location ^~ /static/ {</div>\r\n\r\n			<div class=\"line\">root /webroot/static/;</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {</div>\r\n\r\n			<div class=\"line\">root /webroot/res/;</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</div>\r\n\r\n			<div class=\"line\">#非静态文件请求就默认是动态请求，自己根据实际把握</div>\r\n\r\n			<div class=\"line\">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</div>\r\n\r\n			<div class=\"line\">location / {</div>\r\n\r\n			<div class=\"line\">proxy_pass http://tomcat:8080/</div>\r\n\r\n			<div class=\"line\">}</div>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><a href=\"http://tengine.taobao.org/book/chapter_02.html\" rel=\"external\" target=\"_blank\">http://tengine.taobao.org/book/chapter_02.html</a><br />\r\n<a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"external\" target=\"_blank\">http://nginx.org/en/docs/http/ngx_http_rewrite_module.html</a></p>\r\n\r\n<h1>2. Rewrite规则</h1>\r\n\r\n<p>rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code> 只对/a/we/index.php重写。语法<code>rewrite regex replacement [flag];</code></p>\r\n\r\n<p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。</p>\r\n\r\n<p>表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是：</p>\r\n\r\n<ol>\r\n	<li>执行server块的rewrite指令</li>\r\n	<li>执行location匹配</li>\r\n	<li>执行选定的location中的rewrite指令</li>\r\n</ol>\r\n\r\n<p>如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。</p>\r\n\r\n<h2>2.1 flag标志位</h2>\r\n\r\n<ul>\r\n	<li><code>last</code> : 相当于Apache的[L]标记，表示完成rewrite</li>\r\n	<li><code>break</code> : 停止执行当前虚拟主机的后续rewrite指令集</li>\r\n	<li><code>redirect</code> : 返回302临时重定向，地址栏会显示跳转后的地址</li>\r\n	<li><code>permanent</code> : 返回301永久重定向，地址栏会显示跳转后的地址</li>\r\n</ul>\r\n\r\n<p>因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解：</p>\r\n\r\n<ol>\r\n	<li>last一般写在server和if中，而break一般使用在location中</li>\r\n	<li>last不终止<em>重写后</em>的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配</li>\r\n	<li>break和last都能组织继续执行后面的rewrite指令</li>\r\n</ol>\r\n\r\n<h2>2.2 if指令与全局变量</h2>\r\n\r\n<p><strong>if判断指令</strong><br />\r\n语法为<code>if(condition){...}</code>，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：</p>\r\n\r\n<ul>\r\n	<li>当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false</li>\r\n	<li>直接比较变量和内容时，使用<code>=</code>或<code>!=</code></li>\r\n	<li><code>~</code>正则表达式匹配，<code>~*</code>不区分大小写的匹配，<code>!~</code>区分大小写的不匹配</li>\r\n</ul>\r\n\r\n<p><code>-f</code>和<code>!-f</code>用来判断是否存在文件<br />\r\n<code>-d</code>和<code>!-d</code>用来判断是否存在目录<br />\r\n<code>-e</code>和<code>!-e</code>用来判断是否存在文件或目录<br />\r\n<code>-x</code>和<code>!-x</code>用来判断文件是否可执行</p>\r\n\r\n<p>例如：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">1</div>\r\n\r\n			<div class=\"line\">2</div>\r\n\r\n			<div class=\"line\">3</div>\r\n\r\n			<div class=\"line\">4</div>\r\n\r\n			<div class=\"line\">5</div>\r\n\r\n			<div class=\"line\">6</div>\r\n\r\n			<div class=\"line\">7</div>\r\n\r\n			<div class=\"line\">8</div>\r\n\r\n			<div class=\"line\">9</div>\r\n\r\n			<div class=\"line\">10</div>\r\n\r\n			<div class=\"line\">11</div>\r\n\r\n			<div class=\"line\">12</div>\r\n\r\n			<div class=\"line\">13</div>\r\n\r\n			<div class=\"line\">14</div>\r\n\r\n			<div class=\"line\">15</div>\r\n\r\n			<div class=\"line\">16</div>\r\n\r\n			<div class=\"line\">17</div>\r\n\r\n			<div class=\"line\">18</div>\r\n\r\n			<div class=\"line\">19</div>\r\n\r\n			<div class=\"line\">20</div>\r\n\r\n			<div class=\"line\">21</div>\r\n\r\n			<div class=\"line\">22</div>\r\n\r\n			<div class=\"line\">23</div>\r\n\r\n			<div class=\"line\">24</div>\r\n\r\n			<div class=\"line\">25</div>\r\n\r\n			<div class=\"line\">26</div>\r\n\r\n			<div class=\"line\">27</div>\r\n\r\n			<div class=\"line\">28</div>\r\n\r\n			<div class=\"line\">29</div>\r\n\r\n			<div class=\"line\">30</div>\r\n\r\n			<div class=\"line\">31</div>\r\n			</td>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">if ($http_user_agent ~ MSIE) {</div>\r\n\r\n			<div class=\"line\">rewrite ^(.*)$ /msie/$1 break;</div>\r\n\r\n			<div class=\"line\">} //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) {</div>\r\n\r\n			<div class=\"line\">set $id $1;</div>\r\n\r\n			<div class=\"line\">} //如果cookie匹配正则，设置变量$id等于正则引用部分</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">if ($request_method = POST) {</div>\r\n\r\n			<div class=\"line\">return 405;</div>\r\n\r\n			<div class=\"line\">} //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">if ($slow) {</div>\r\n\r\n			<div class=\"line\">limit_rate 10k;</div>\r\n\r\n			<div class=\"line\">} //限速，$slow可以通过 set 指令设置</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">if (!-f $request_filename){</div>\r\n\r\n			<div class=\"line\">break;</div>\r\n\r\n			<div class=\"line\">proxy_pass http://127.0.0.1;</div>\r\n\r\n			<div class=\"line\">} //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">if ($args ~ post=140){</div>\r\n\r\n			<div class=\"line\">rewrite ^ http://example.com/ permanent;</div>\r\n\r\n			<div class=\"line\">} //如果query string中包含&quot;post=140&quot;，永久重定向到example.com</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location ~* \\.(gif|jpg|png|swf|flv)$ {</div>\r\n\r\n			<div class=\"line\">valid_referers none blocked www.jefflei.com www.leizhenfang.com;</div>\r\n\r\n			<div class=\"line\">if ($invalid_referer) {</div>\r\n\r\n			<div class=\"line\">return 404;</div>\r\n\r\n			<div class=\"line\">} //防盗链</div>\r\n\r\n			<div class=\"line\">}</div>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>全局变量</strong><br />\r\n下面是可以用作if判断的全局变量</p>\r\n\r\n<ul>\r\n	<li><code>$args</code> ： #这个变量等于请求行中的参数，同<code>$query_string</code></li>\r\n	<li><code>$content_length</code> ： 请求头中的Content-length字段。</li>\r\n	<li><code>$content_type</code> ： 请求头中的Content-Type字段。</li>\r\n	<li><code>$document_root</code> ： 当前请求在root指令中指定的值。</li>\r\n	<li><code>$host</code> ： 请求主机头字段，否则为服务器名称。</li>\r\n	<li><code>$http_user_agent</code> ： 客户端agent信息</li>\r\n	<li><code>$http_cookie</code> ： 客户端cookie信息</li>\r\n	<li><code>$limit_rate</code> ： 这个变量可以限制连接速率。</li>\r\n	<li><code>$request_method</code> ： 客户端请求的动作，通常为GET或POST。</li>\r\n	<li><code>$remote_addr</code> ： 客户端的IP地址。</li>\r\n	<li><code>$remote_port</code> ： 客户端的端口。</li>\r\n	<li><code>$remote_user</code> ： 已经经过Auth Basic Module验证的用户名。</li>\r\n	<li><code>$request_filename</code> ： 当前请求的文件路径，由root或alias指令与URI请求生成。</li>\r\n	<li><code>$scheme</code> ： HTTP方法（如http，https）。</li>\r\n	<li><code>$server_protocol</code> ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li>\r\n	<li><code>$server_addr</code> ： 服务器地址，在完成一次系统调用后可以确定这个值。</li>\r\n	<li><code>$server_name</code> ： 服务器名称。</li>\r\n	<li><code>$server_port</code> ： 请求到达服务器的端口号。</li>\r\n	<li><code>$request_uri</code> ： 包含请求参数的原始URI，不包含主机名，如：&rdquo;/foo/bar.php?arg=baz&rdquo;。</li>\r\n	<li><code>$uri</code> ： 不带请求参数的当前URI，$uri不包含主机名，如&rdquo;/foo/bar.html&rdquo;。</li>\r\n	<li><code>$document_uri</code> ： 与$uri相同。</li>\r\n</ul>\r\n\r\n<p>例：<code>http://localhost:88/test1/test2/test.php</code><br />\r\n$host：localhost<br />\r\n$server_port：88<br />\r\n$request_uri：<a href=\"http://localhost:88/test1/test2/test.php\" rel=\"external\" target=\"_blank\">http://localhost:88/test1/test2/test.php</a><br />\r\n$document_uri：/test1/test2/test.php<br />\r\n$document_root：/var/www/html<br />\r\n$request_filename：/var/www/html/test1/test2/test.php</p>\r\n\r\n<h2>2.3 常用正则</h2>\r\n\r\n<ul>\r\n	<li><code>.</code> ： 匹配除换行符以外的任意字符</li>\r\n	<li><code>?</code> ： 重复0次或1次</li>\r\n	<li><code>+</code> ： 重复1次或更多次</li>\r\n	<li><code>*</code> ： 重复0次或更多次</li>\r\n	<li><code>\\d</code> ：匹配数字</li>\r\n	<li><code>^</code> ： 匹配字符串的开始</li>\r\n	<li><code>$</code> ： 匹配字符串的介绍</li>\r\n	<li><code>{n}</code> ： 重复n次</li>\r\n	<li><code>{n,}</code> ： 重复n次或更多次</li>\r\n	<li><code>[c]</code> ： 匹配单个字符c</li>\r\n	<li><code>[a-z]</code> ： 匹配a-z小写字母的任意一个</li>\r\n</ul>\r\n\r\n<p>小括号<code>()</code>之间匹配的内容，可以在后面通过<code>$1</code>来引用，<code>$2</code>表示的是前面第二个<code>()</code>里的内容。正则里面容易让人困惑的是<code>\\</code>转义特殊字符。</p>\r\n\r\n<h2>2.4 rewrite实例</h2>\r\n\r\n<p><em>例1</em>：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">1</div>\r\n\r\n			<div class=\"line\">2</div>\r\n\r\n			<div class=\"line\">3</div>\r\n\r\n			<div class=\"line\">4</div>\r\n\r\n			<div class=\"line\">5</div>\r\n\r\n			<div class=\"line\">6</div>\r\n\r\n			<div class=\"line\">7</div>\r\n\r\n			<div class=\"line\">8</div>\r\n\r\n			<div class=\"line\">9</div>\r\n\r\n			<div class=\"line\">10</div>\r\n\r\n			<div class=\"line\">11</div>\r\n\r\n			<div class=\"line\">12</div>\r\n\r\n			<div class=\"line\">13</div>\r\n\r\n			<div class=\"line\">14</div>\r\n\r\n			<div class=\"line\">15</div>\r\n\r\n			<div class=\"line\">16</div>\r\n\r\n			<div class=\"line\">17</div>\r\n\r\n			<div class=\"line\">18</div>\r\n\r\n			<div class=\"line\">19</div>\r\n\r\n			<div class=\"line\">20</div>\r\n\r\n			<div class=\"line\">21</div>\r\n\r\n			<div class=\"line\">22</div>\r\n\r\n			<div class=\"line\">23</div>\r\n\r\n			<div class=\"line\">24</div>\r\n\r\n			<div class=\"line\">25</div>\r\n\r\n			<div class=\"line\">26</div>\r\n\r\n			<div class=\"line\">27</div>\r\n\r\n			<div class=\"line\">28</div>\r\n\r\n			<div class=\"line\">29</div>\r\n\r\n			<div class=\"line\">30</div>\r\n\r\n			<div class=\"line\">31</div>\r\n			</td>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">http {</div>\r\n\r\n			<div class=\"line\"># 定义image日志格式</div>\r\n\r\n			<div class=\"line\">log_format imagelog &#39;[$time_local] &#39; $image_file &#39; &#39; $image_type &#39; &#39; $body_bytes_sent &#39; &#39; $status;</div>\r\n\r\n			<div class=\"line\"># 开启重写日志</div>\r\n\r\n			<div class=\"line\">rewrite_log on;</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">server {</div>\r\n\r\n			<div class=\"line\">root /home/www;</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location / {</div>\r\n\r\n			<div class=\"line\"># 重写规则信息</div>\r\n\r\n			<div class=\"line\">error_log logs/rewrite.log notice;</div>\r\n\r\n			<div class=\"line\"># 注意这里要用&lsquo;&rsquo;单引号引起来，避免{}</div>\r\n\r\n			<div class=\"line\">rewrite &#39;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\\.(png|jpg|gif)$&#39; /data?file=$3.$4;</div>\r\n\r\n			<div class=\"line\"># 注意不能在上面这条规则后面加上&ldquo;last&rdquo;参数，否则下面的set指令不会执行</div>\r\n\r\n			<div class=\"line\">set $image_file $3;</div>\r\n\r\n			<div class=\"line\">set $image_type $4;</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">&nbsp;</div>\r\n\r\n			<div class=\"line\">location /data {</div>\r\n\r\n			<div class=\"line\"># 指定针对图片的日志格式，来分析图片类型和大小</div>\r\n\r\n			<div class=\"line\">access_log logs/images.log mian;</div>\r\n\r\n			<div class=\"line\">root /data/images;</div>\r\n\r\n			<div class=\"line\"># 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里</div>\r\n\r\n			<div class=\"line\">try_files /$arg_file /image404.html;</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">location = /image404.html {</div>\r\n\r\n			<div class=\"line\"># 图片不存在返回特定的信息</div>\r\n\r\n			<div class=\"line\">return 404 &quot;image not found\\n&quot;;</div>\r\n\r\n			<div class=\"line\">}</div>\r\n\r\n			<div class=\"line\">}</div>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>对形如<code>/images/ef/uh7b3/test.png</code>的请求，重写到<code>/data?file=test.png</code>，于是匹配到<code>location /data</code>，先看<code>/data/images/test.png</code>文件存不存在，如果存在则正常响应，如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。</p>\r\n\r\n<p><em>例2</em>：</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">1</div>\r\n			</td>\r\n			<td>\r\n			<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n			<div class=\"line\">rewrite ^/images/(.*)_(\\d+)x(\\d+)\\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=$3? last;</div>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>对形如<code>/images/bla_500x400.jpg</code>的文件请求，重写到<code>/resizer/bla.jpg?width=500&amp;height=400</code>地址，并会继续尝试匹配location。</p>\r\n',7,'孟祥坤','ff7e4147-1af0-4332-90d3-780733410ce4.png'),(63,'java','Nginx —— 理解HTTP 代理，负载均衡，缓冲（Buffering）和缓存（Caching）','2017-08-21 19:16:25',NULL,'我们将介绍 Nginx 的 Http 代理功能（请求（request） 通过 Nignx 传递到后端服务器，进行后续处理）。Nginx 经常设置为 反向代理（Reverse Proxy） 帮助 横向扩展（scale out：通过增加独立服务器来增加运算能力） 基础架构（infrastructure） 来提升负载能力或者传递请求给下一级代理服务器','<h2>常规的代理信息</h2>\r\n\r\n<p>如果你之前只是部署单台 Web 服务器，那你可能会想知道为什么需要代理请求。</p>\r\n\r\n<p><strong>横向扩展（scale out）</strong>&nbsp;提升&nbsp;<strong>基础架构（infrastructure）</strong>&nbsp;的能力是使用代理的原因之一。<strong>Nignx</strong>&nbsp;的设计初衷就是被用来处理并发请求，是客户端接触点的理想选择。代理服务器可以传递&nbsp;<strong>request</strong>&nbsp;给多个能处理大量任务的后端服务器，达到跨设备分散负载的目的。这样的设计同样也能帮助你更容易得添加服务器或者下线需要维护的服务器。</p>\r\n\r\n<p>当应用服务器没有直接处理&nbsp;<strong>request</strong>&nbsp;的能力的时候，代理服务器就可以发挥作用了。很多框架（包括 Web 服务器）不如专门设计成高性能服务器（如&nbsp;<strong>Nignx</strong>）那样健壮。这种场景下，把&nbsp;<strong>Nginx</strong>&nbsp;放在这些服务之前，可以提升用户体验和安全性。</p>\r\n\r\n<p><strong>Nigix</strong>&nbsp;通过接收&nbsp;<strong>request</strong>，把它转发给其他服务器处理来完成代理过程的。<strong>request</strong>&nbsp;的处理结果会返回&nbsp;<strong>Nginx</strong>，然后转发给客户端。实例中的其他服务器可以是远程机器，本地服务，甚至是由&nbsp;<strong>Nginx</strong>&nbsp;定义的其他虚拟服务。由&nbsp;<strong>Nginx</strong>&nbsp;代理的服务器，我们称之为&nbsp;<strong>upstream</strong>（上游）服务。</p>\r\n\r\n<p><strong>Nginx</strong>&nbsp;可以代理使用&nbsp;<strong>http(s)</strong>,&nbsp;<strong>FastCGI</strong>,&nbsp;<strong>SCGI</strong>&nbsp;和&nbsp;<strong>uwsgi</strong>&nbsp;的请求，或者为每种代理类型指定不同指令的&nbsp;<strong>memcached</strong>&nbsp;协议。在这个指南中，我们专注于&nbsp;<strong>http</strong>&nbsp;协议。&nbsp;<strong>Nginx</strong>&nbsp;实例负责传递&nbsp;<strong>request</strong>，并把各个信息融合成一个&nbsp;<strong>upstream</strong>&nbsp;可理解的格式。</p>\r\n\r\n<h2>解构一个简单的 HTTP 代理传递过程</h2>\r\n\r\n<p>最简单的代理类型莫过于把一个&nbsp;<strong>request</strong>&nbsp;导向到单一使用 http 协议通信的服务器了。我们把这类代理统称为&nbsp;<strong>proxy pass</strong>，由&nbsp;<code>proxy_pass</code>&nbsp;指令处理。</p>\r\n\r\n<p><code>proxy_pass</code>&nbsp;指令主要在&nbsp;<code>location</code>&nbsp;的&nbsp;<strong>context（中文含义：语境或上下文）</strong>&nbsp;中使用。它还可以在&nbsp;<code>location</code>&nbsp;和&nbsp;<code>limit_except</code>的&nbsp;<strong>context</strong>&nbsp;的&nbsp;<code>if</code>&nbsp;语法块中使用。当&nbsp;<strong>request</strong>&nbsp;匹配到一个包含&nbsp;<code>proxy_pass</code>&nbsp;的&nbsp;<code>location</code>&nbsp;中时， 该&nbsp;<strong>request</strong>&nbsp;将会被指令转发（Forward）到这个链接去。</p>\r\n\r\n<p>让我们看一个例子：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>在上面代码片段中，<code>proxy_pass</code>&nbsp;语句中的服务器地址没有提供 URI。在该模式下，&nbsp;<strong>request</strong>&nbsp;的&nbsp;<strong>URI</strong>&nbsp;会原封不动地直接传递给&nbsp;<strong>upstream</strong>&nbsp;服务器。来看个例子：</p>\r\n\r\n<ul>\r\n	<li><strong>Nginx</strong>&nbsp;所接受的&nbsp;<strong>request</strong>&nbsp;的原始 URI:&nbsp;<code>/match/here/please</code></li>\r\n	<li><code>example.com</code>&nbsp;从&nbsp;<strong>Nginx</strong>&nbsp;接收到的形式：<code>http://example.com/match/here/please</code></li>\r\n</ul>\r\n\r\n<p>让我们一起看看另外一个场景：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>上述例子中，代理服务器在尾部定义了 URI。当 URI 放到&nbsp;<code>proxy_pass</code>&nbsp;定义中时，&nbsp;<strong>request</strong>&nbsp;中匹配这个&nbsp;<code>location</code>&nbsp;的部分会在传递的过程中将会被这个 URI 直接覆盖掉，再来看个例子：</p>\r\n\r\n<ul>\r\n	<li><strong>Nginx</strong>&nbsp;所接受的&nbsp;<strong>request</strong>&nbsp;的原始 URI:&nbsp;<code>/match/here/please</code></li>\r\n	<li><strong>upstream</strong>&nbsp;服务器 从&nbsp;<strong>Nginx</strong>&nbsp;接收到的形式:&nbsp;<code>http://example.com/new/prefix/please</code>，这里&nbsp;<code>/match/here</code>&nbsp;被替换成&nbsp;<code>/new/prefix</code></li>\r\n</ul>\r\n\r\n<p>有时，这样的替换是失效。这时，定义在&nbsp;<code>proxy_pass</code>&nbsp;的尾部的 URI 会被忽略，<strong>Nginx</strong>&nbsp;直接把来自客户端或被其他&nbsp;<strong>Nginx</strong>&nbsp;的指令修改的 URI 传递给&nbsp;<strong>upstream</strong>&nbsp;服务器。</p>\r\n\r\n<p>例如，使用正则表达式匹配&nbsp;<code>location</code>， URI 的匹配出现争议时，<strong>Nginx</strong>&nbsp;直接发送客户端&nbsp;<strong>upstream</strong>&nbsp;的原始 URI。还有另一个例子，当一个&nbsp;<strong>rewrite</strong>&nbsp;指令在同一个地址中使用，会导致客户端的 URI 被重写，但是仍然在同一个&nbsp;<strong>block</strong>&nbsp;下处理。这时，传递的 URI 是重写后的。</p>\r\n\r\n<h2>理解 Nginx 处理 Headers 的方式</h2>\r\n\r\n<p>如果你希望&nbsp;<strong>upstream</strong>&nbsp;能合理地处理&nbsp;<strong>request</strong>&nbsp;，那仅仅传递 URI 是不够的。来自于&nbsp;<strong>Nginx</strong>&nbsp;的&nbsp;<strong>request</strong>&nbsp;和直接来源于客户端的&nbsp;<strong>request</strong>&nbsp;之间还是有区别的。这里最大的差异来自于&nbsp;<strong>request</strong>&nbsp;的&nbsp;<strong>Headers（头信息）</strong>。</p>\r\n\r\n<p>当&nbsp;<strong>Nginx</strong>&nbsp;代理一个&nbsp;<strong>request</strong>&nbsp;，它会自动对&nbsp;<strong>Headers</strong>&nbsp;做一些调整：</p>\r\n\r\n<ul>\r\n	<li><strong>Nginx</strong>&nbsp;会去除任何空的&nbsp;<strong>Headers</strong>。转发空值是没有意义的；它只会让&nbsp;<strong>request</strong>&nbsp;变得臃肿。</li>\r\n	<li><strong>Nginx</strong>&nbsp;默认把名称包含下划线的&nbsp;<strong>Headers</strong>&nbsp;视为无效，直接移除。如果你希望让这类型的信息生效，那你要把&nbsp;<code>underscores_in_headers</code>&nbsp;指令设置成&nbsp;<code>on</code>，否则这样的头信息将不会把他发送给后端服务器。</li>\r\n	<li><code>Host</code>&nbsp;会被重写成由&nbsp;<code>$proxy_host</code>&nbsp;定义的值。它可以是由&nbsp;<code>proxy_pass</code>&nbsp;指令定义的&nbsp;<strong>upstream</strong>&nbsp;的&nbsp;<code>IP</code>&nbsp;（或者名称）和端口。</li>\r\n	<li><strong>Headers</strong>&nbsp;中的&nbsp;<strong>Connection</strong>&nbsp;改成&nbsp;<code>close</code>。这个&nbsp;<strong>Headers</strong>&nbsp;用在两个服务器创建特定连接的信号信息。在这个实例中，<strong>Nginx</strong>把它设置成&nbsp;<code>close</code>，一旦原始&nbsp;<strong>request</strong>&nbsp;被响应，<strong>upstream</strong>&nbsp;的这个连接将被关闭。<strong>upstream</strong>&nbsp;不应该期望这个连接被持久化。</li>\r\n</ul>\r\n\r\n<p>从第一点看来，我们可以确定任何不希望被转发的&nbsp;<strong>Headers</strong>&nbsp;都应该被设置成空字符串。带空值的&nbsp;<strong>Headers</strong>&nbsp;会被完全删除掉。</p>\r\n\r\n<p>接下来一点用来设置如果你的后端应用想要接受非标准的&nbsp;<strong>Headers</strong>，你应该确保它们不应该带下划线。如果你需要的&nbsp;<strong>Headers</strong>&nbsp;使用了下划线，你你需要把&nbsp;<code>underscores_in_headers</code>&nbsp;指令设置成&nbsp;<code>on</code>（在&nbsp;<code>http</code>&nbsp;的&nbsp;<strong>context</strong>&nbsp;或者为这个 IP 和端口组合声明的默认服务器的&nbsp;<strong>context</strong>&nbsp;中有效）。如果你不想这么做，<strong>Nginx</strong>&nbsp;将会把这类&nbsp;<strong>Headers</strong>&nbsp;标记为无效，并在传递给&nbsp;<strong>upstream</strong>&nbsp;之前把它丢弃。</p>\r\n\r\n<p><strong>Headers</strong>&nbsp;的&nbsp;<strong>Host</strong>&nbsp;在大部分代理场景中都起着重要作用，它默认被设置成&nbsp;<code>$proxy_host</code>&nbsp;的值，一个由&nbsp;<code>proxy_pass</code>&nbsp;定义的包含 IP 或名称和端口的值。这样的默认设定是为了让&nbsp;<strong>Nginx</strong>&nbsp;确保&nbsp;<strong>upsteam</strong>&nbsp;可以响应的地址是唯一的（它直接从连接信息取出）。</p>\r\n\r\n<p><strong>Host</strong>&nbsp;常见的值如下：</p>\r\n\r\n<ul>\r\n	<li><code>$proxy_host</code>：它把&nbsp;<strong>Host</strong>&nbsp;设置成从&nbsp;<code>proxy_pass</code>&nbsp;定义的 IP 或名称加上端口的组合。从&nbsp;<strong>Nginx</strong>&nbsp;的角度看，它是默认以及安全的，但是经常不是被代理服务器需要的来正确处理请求的值。</li>\r\n	<li><code>$http_host</code>：它把&nbsp;<strong>Host</strong>&nbsp;设置成客户端&nbsp;<strong>request</strong>&nbsp;的&nbsp;<strong>Headers</strong>&nbsp;中相关信息。这个&nbsp;<strong>Headers</strong>&nbsp;由客户端发送，可以被&nbsp;<strong>Nginx</strong>&nbsp;使用。这个变量名前缀是&nbsp;<code>$http_</code>，后面紧跟着&nbsp;<strong>Headers</strong>&nbsp;的名称，以小写命名，任何斜杠都会被下划线替换。虽然&nbsp;<code>$http_host</code>在大部分情况可用的，但是当客户端的&nbsp;<strong>request</strong>&nbsp;没有有效的&nbsp;<strong>Host</strong>&nbsp;信息的时候，会导致传输失败。</li>\r\n	<li><code>$host</code>：这个是偏好设置，它可以是来自&nbsp;<strong>request</strong>&nbsp;的主机名，请求中的&nbsp;<strong>Host</strong>&nbsp;或者匹配请求的服务器名。</li>\r\n</ul>\r\n\r\n<p>在大部分情况，你将会把&nbsp;<strong>Host</strong>&nbsp;设置成&nbsp;<code>$host</code>&nbsp;变量。它是最灵活的，经常为被代理的服务器提供尽可能精确的&nbsp;<strong>Host</strong>&nbsp;信息。</p>\r\n\r\n<h2>配置或者重置 Headers</h2>\r\n\r\n<p>为了适配代理连接，我们可以使用&nbsp;<code>proxy_set_header</code>&nbsp;指令。例如，为了改变我们之前讨论的&nbsp;<strong>Host</strong>&nbsp;以及其它的&nbsp;<strong>Headers</strong>&nbsp;中的配置，我们可以这么做：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nlocation /match/here {\r\n    proxy_set_header HOST $host;\r\n    proxy_set_header X-Forwarded-Proto $scheme;\r\n    proxy_set_header X-Real-IP $remote_addr;\r\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>上述配置把&nbsp;<strong>request</strong>&nbsp;中&nbsp;<strong>Headers</strong>&nbsp;的&nbsp;<strong>Host</strong>&nbsp;设置成&nbsp;<code>$host</code>&nbsp;变量，它将包含&nbsp;<strong>request</strong>&nbsp;的原始主机名。<strong>Headers</strong>&nbsp;的&nbsp;<code>X-Forwarded-Proto</code>&nbsp;提供了关于原始&nbsp;<strong>request</strong>&nbsp;的&nbsp;<strong>Headers</strong>&nbsp;中被代理服务器协议（http 还是 https）。</p>\r\n\r\n<p><code>X-Real-IP</code>&nbsp;被设置成客户端的 IP 地址，以便代理服务器做判定或者记录基于该信息的日志。<code>X-Forwarded-For</code>&nbsp;是一个包含整个代理过程经过的所有服务器 IP 的地址列表。在上述例子中，我们把它设置成&nbsp;<code>$proxy_add_x_forwarded_for</code>&nbsp;变量。这个变量包含了从客户端获取的&nbsp;<code>X-Forwarded-For</code>&nbsp;和&nbsp;<strong>Nginx</strong>&nbsp;服务器的 IP（按照&nbsp;<strong>request</strong>&nbsp;的顺序）。</p>\r\n\r\n<p>当然，我们也可以把&nbsp;<code>proxy_set_header</code>&nbsp;指令移到&nbsp;<code>server</code>&nbsp;或者&nbsp;<code>http</code>&nbsp;的&nbsp;<strong>context</strong>&nbsp;中，让它同时在该&nbsp;<strong>context</strong>&nbsp;的多个&nbsp;<code>location</code>中生效：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nproxy_set_header HOST $host;\r\nproxy_set_header X-Forwarded-Proto $scheme;\r\nproxy_set_Header X-Real-IP $remote_addr;\r\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\nlocation /match/here {\r\n    proxy_pass http://example.com/new/prefix;\r\n}\r\n\r\nlocation /different/match {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n\r\n<h2>为负载均衡代理服务器定义 Upstream 语境（Context）</h2>\r\n\r\n<p>在上一个例子中，我们演示了如何为了一个单台后端服务器实现简单的 http 代理。<strong>Nginx</strong>&nbsp;让我们很容易通过指定一个后端服务器集群池子来扩展这个配置。</p>\r\n\r\n<p>我们使用&nbsp;<code>upstream</code>&nbsp;指令来定义服务器群的池子（pool）。这个配置假设服务器列表中的每台机子都可以处理来自客户端的&nbsp;<strong>request</strong>。我们可以通过它轻轻松松地&nbsp;<strong>横向扩展（scale out）</strong>&nbsp;我们的&nbsp;<strong>基础架构（infrastructure）</strong>。<code>upstream</code>&nbsp;指令必须定义在&nbsp;<strong>Nginx</strong>&nbsp;的&nbsp;<code>http</code>&nbsp;的&nbsp;<strong>context</strong>&nbsp;中。</p>\r\n\r\n<p>让我们一起看个简单的例子：</p>\r\n\r\n<pre>\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    server_name example.com;\r\n\r\n    location /proxy-me {\r\n        proxy_pass http://backend_hosts;\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p>上述例子，我们设置一个叫做&nbsp;<code>backend_hosts</code>&nbsp;的&nbsp;<code>upstream</code>&nbsp;<strong>context</strong>。一旦定义了，这个名称可以直接在&nbsp;<code>proxy_pass</code>&nbsp;中使用，就和常规的域名一样。如你所见，在我们的服务器块内，所有指向&nbsp;<em>example.com/proxy-me/&hellip;</em>&nbsp;的&nbsp;<strong>request</strong>&nbsp;都会被传递到我们定义的池子中。在池子里，会根据配置的算法选取一台服务器。默认，它只是一个简单的<strong>round-robin（循环选择）</strong>&nbsp;处理（即每一个请求都会按顺序传递给不同的服务器）。</p>\r\n\r\n<h3>改变 Upstream 均衡算法</h3>\r\n\r\n<p>你可以通过指令修改&nbsp;<strong>upstream</strong>&nbsp;池子的&nbsp;<strong>均衡算法（balancing algorithm）</strong>：</p>\r\n\r\n<ul>\r\n	<li><strong>round-robin（循环选择）</strong>：默认的算法。在其它算法没被指定的情况下，它会被使用。<code>upstream</code>&nbsp;<strong>context</strong>&nbsp;定义的每一个服务器都会按顺序接受&nbsp;<strong>request</strong>。</li>\r\n	<li><strong>least_conn（最少连接）</strong>: 指定新的&nbsp;<strong>request</strong>&nbsp;永远只会传递给拥有最少连接的后端服务器。在后端连接需要被持久化的情况下，这个算法将很有效。</li>\r\n	<li><strong>ip_hash</strong>：这种&nbsp;<strong>均衡算法（balancing algorithm）</strong>&nbsp;是基于客户端的 IP 来分发&nbsp;<strong>request</strong>&nbsp;到不同的服务器。把客户端 IP 的前三位八进制数作为键值来决定由哪台服务器处理。这样，同一 IP 的客户端每次只会由同一个台服务器处理；它能保证&nbsp;<strong>session（会话）</strong>&nbsp;的一致性。</li>\r\n	<li><strong>hash</strong>：这种&nbsp;<strong>均衡算法（balancing algorithm）</strong>&nbsp;主要运用于缓存代理。这是唯一一种需要用户提供数据的算法；算法根据用户所提供数据的哈希值来决定服务器的分配。它可以是文本，变量或者文本和变量的组合。</li>\r\n</ul>\r\n\r\n<p>修改&nbsp;<strong>均衡算法（balancing algorithm）</strong>&nbsp;，应该像下面那样：</p>\r\n\r\n<pre>\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n\r\n    least_conn;\r\n\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>上述例子中，拥有最少连接数的服务器将会优先选择。<code>ip_hash</code>&nbsp;指令也可以用同样的方式设置，来保证&nbsp;<strong>session（会话）</strong>&nbsp;的一致性。</p>\r\n\r\n<p>至于&nbsp;<code>hash</code>&nbsp;方法，你应该提供要哈希的键。可以是任何你想要的：</p>\r\n\r\n<pre>\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n\r\n    hash $remote_addr$remote_port consistent;\r\n\r\n    server host1.example.com;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>上述的例子，<strong>request</strong>&nbsp;的分发是基于客户端的 IP 和端口；我们还可以添加另外的参数&nbsp;<code>consistent</code>，它实现了&nbsp;<strong>ketama consistent hashing</strong>&nbsp;算法。基本上，它意味着如果你的&nbsp;<strong>upstream</strong>&nbsp;服务器改变了，可以保证对&nbsp;<strong>cache（缓存）</strong>&nbsp;的最小影响。</p>\r\n\r\n<h3>设置服务器权重</h3>\r\n\r\n<p>在后端服务器声明中，每一台的服务器默认是权重平分的。它假定每一台服务器都能且应该处理同一量级的负载（考虑到&nbsp;<strong>均衡算法（balancing algorithm）</strong>&nbsp;的影响）。然而，你也可以为服务器设置其它的权重。</p>\r\n\r\n<pre>\r\n<code># http context\r\n\r\nupstream backend_hosts {\r\n    server host1.example.com weight=3;\r\n    server host2.example.com;\r\n    server host3.example.com;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>上述例子中，<code>host1.example.com</code>&nbsp;可以比其它服务器多接受 2 倍的流量。默认，每一台服务器的权重都是 1。</p>\r\n\r\n<h2>使用 Buffer 缓解后端的负载</h2>\r\n\r\n<p>对于大部分使用代理的用户来说，最关心的事情之一就是增加一台服务器对性能的影响。在大部分场景下，利用&nbsp;<strong>Nginx</strong>&nbsp;的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;和&nbsp;<strong>cache（缓存）</strong>&nbsp;能力，可以大大地减轻负担。</p>\r\n\r\n<p>在代理过程中，两个连接速度不一会对客户端的体验带来不良的影响：</p>\r\n\r\n<ul>\r\n	<li>从客户端到代理服务器的连接</li>\r\n	<li>从代理服务器到后端服务器的连接</li>\r\n</ul>\r\n\r\n<p><strong>Nginx</strong>&nbsp;可以根据你希望优化哪一个连接来调整它的行为。</p>\r\n\r\n<p>没有&nbsp;<strong>buffer（缓冲）</strong>，数据将会直接从代理服务器传输到客户端。如果客户端的速度足够快（假设），你可以直接把&nbsp;<strong>buffer（缓冲）</strong>&nbsp;关掉，让数据尽可能快速地到达；如果使用&nbsp;<strong>buffer（缓冲）</strong>，<strong>Nginx</strong>&nbsp;将会临时存储后端&nbsp;<strong>response（响应）</strong>，然后慢慢把数据推送给客户端；如果客户端很慢，<strong>Nginx</strong>&nbsp;会提前关闭后端服务器的连接。它可以任意控制分发的节奏。</p>\r\n\r\n<p><strong>Nginx</strong>&nbsp;默认的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;设计的初衷就是因为客户端之间速度存在差异。我们可以使用如下指令来调整&nbsp;<strong>buffer（缓冲）</strong>&nbsp;速度。你可以把&nbsp;<strong>buffer（缓冲）</strong>&nbsp;配置在&nbsp;<code>http</code>，<code>server</code>&nbsp;或者&nbsp;<code>location</code>&nbsp;的&nbsp;<strong>context</strong>&nbsp;中。必须注意指令为每一个，<strong>request</strong>&nbsp;配置的大小；在客户端的&nbsp;<strong>request</strong>&nbsp;很多的情况下，如果把值调的过大，会很影响性能：</p>\r\n\r\n<ul>\r\n	<li><code>porxy_buffering</code>：这个指令控制所在&nbsp;<strong>context</strong>&nbsp;或者子&nbsp;<strong>context</strong>&nbsp;的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;是否打开。默认是&nbsp;<code>on</code>。</li>\r\n	<li><code>proxy_buffers</code>：这个指令控制&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的数量（第一个参数）和大小（第二个参数）。默认是&nbsp;<code>8</code>&nbsp;个&nbsp;<strong>buffer（缓冲）</strong>，每个&nbsp;<strong>buffer（缓冲）</strong>&nbsp;大小是&nbsp;<code>1</code>&nbsp;个内存页（<code>4k</code>&nbsp;或&nbsp;<code>8k</code>）。增加&nbsp;<strong>buffer</strong>&nbsp;的数量可以缓冲更多的信息。</li>\r\n	<li><code>proxy_buffer_size</code>：是来自后端服务器&nbsp;<strong>response</strong>&nbsp;信息的一部分，它包含&nbsp;<strong>Headers</strong>，从&nbsp;<strong>response</strong>&nbsp;分离出来。这个指令设置&nbsp;<strong>response</strong>&nbsp;的缓冲。默认，它和&nbsp;<code>proxy_buffers</code>&nbsp;一样，但是因为它仅用于&nbsp;<strong>Headers</strong>，所有它的值一般设置得更低。</li>\r\n	<li><code>proxy_busy_buffer_size</code>：这个指令设置忙时&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的最大值。一个客户端一次只能从一个&nbsp;<strong>buffer（缓冲）</strong>&nbsp;中读取数据的同时，剩下的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;会被放到队列中，等待发送到客户端。这个指令控制在这个状态下&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的空间大小</li>\r\n	<li><code>proxy_max_temp_file_size</code>：当代理服务器的&nbsp;<strong>response</strong>&nbsp;太大超出配置的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的时候，它来控制&nbsp;<strong>Nginx</strong>&nbsp;单次可以写入临时文件的最大数据量。</li>\r\n	<li><code>proxy_temp_path</code>：当代理服务器的&nbsp;<strong>response</strong>&nbsp;太大超出配置的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的时候，<strong>Nginx</strong>&nbsp;写临时文件的路径。</li>\r\n</ul>\r\n\r\n<p>正如你看到的，<strong>Nginx</strong>&nbsp;提供了这几个指令来调整&nbsp;<strong>buffer（缓冲）</strong>&nbsp;行为。大部分时间，你不需要关心这些指令中的大部分；但是它们中的一些会很有用，可能最有用的就是&nbsp;<code>proxy_buffer</code>&nbsp;和&nbsp;<code>proxy_buffer_size</code>&nbsp;这两个指令。</p>\r\n\r\n<p>下面这个例子中增加每个&nbsp;<strong>upstream</strong>&nbsp;可用代理&nbsp;<strong>buffer（缓冲）</strong>&nbsp;数，减少存储&nbsp;<strong>Headers</strong>&nbsp;的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;数：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nproxy_buffering on;\r\nproxy_buffer_size 1k;\r\nproxy_buffers 24 4k;\r\nproxy_busy_buffers_size 8k;\r\nproxy_max_temp_file_size 2048m;\r\nproxy_temp_file_write_size 32k;\r\n\r\nlocation / {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n\r\n<p>相反，如果你的客户端足够快到你可以直接传输数据，你就可以完全关掉&nbsp;<strong>buffer（缓冲）</strong>。实际上，即使&nbsp;<strong>upstream</strong>&nbsp;比客户端快很多，<strong>Nginx</strong>&nbsp;还是会使用&nbsp;<strong>buffer（缓冲）</strong>&nbsp;的，但是它会直接清空客户端的数据，不会让它进入到&nbsp;<strong>buffer（缓冲）</strong>&nbsp;池子。如果客户端很慢，这会导致&nbsp;<strong>upstream</strong>&nbsp;连接会一直开到客户端处理完为止。当&nbsp;<strong>buffer（缓冲）</strong>&nbsp;被设置为&nbsp;<code>off</code>&nbsp;的时候，只有&nbsp;<code>proxy_buffer_size</code>&nbsp;指令定义的&nbsp;<strong>buffer（缓冲）</strong>&nbsp;会被使用。</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nproxy_buffering off;\r\nproxy_buffer_size 4k;\r\n\r\nlocation / {\r\n    proxy_pass http://example.com;\r\n}\r\n</code></pre>\r\n\r\n<h2>高可用性（可选）</h2>\r\n\r\n<p>你可以通过添加一个冗余的负载均衡器来使&nbsp;<strong>Nginx</strong>&nbsp;代理更加健壮，创建一个高可用性基础设施。</p>\r\n\r\n<p>一个&nbsp;<strong>高可用（HA）</strong>&nbsp;的配置是一种容许单点错误（single point of failure）的基础设施，你的负载均衡是这个配置的一部分。当你的负载均衡器不可用或者你需要下线维护，你可以通过配置多个负载均衡器防止潜在的停机风险。</p>\r\n\r\n<p>这是基本高可用架构图：</p>\r\n\r\n<p><img alt=\"高可用架构图\" src=\"https://assets.digitalocean.com/articles/high_availability/ha-diagram-animated.gif\" style=\"height:286px; width:600px\" /></p>\r\n\r\n<p>这个例子中，在静态 IP （它可以映射到一台或多台服务器）背后配置多个负载均衡器（一个是激活的，其它的一或多个是被动激活的）。客户端&nbsp;<strong>request</strong>&nbsp;从静态 IP 路由到激活的负载均衡器，然后到后端服务器。想了解更多，请阅读&nbsp;<a href=\"https://www.digitalocean.com/community/tutorials/how-to-use-floating-ips-on-digitalocean#how-to-implement-an-ha-setup\">this section of How To Use Floating IPs</a>。</p>\r\n\r\n<h2>配置代理缓存来减少响应时间</h2>\r\n\r\n<p><strong>buffer（缓冲）</strong>&nbsp;帮助减轻后端服务器负担达到处理更多&nbsp;<strong>request</strong>&nbsp;目的的同时，<strong>Nginx</strong>&nbsp;还提供一个从后端服务器缓存内容的功能，减少要连接&nbsp;<strong>upstream</strong>&nbsp;的次数。</p>\r\n\r\n<h3>配置代理缓存</h3>\r\n\r\n<p>我们使用&nbsp;<code>proxy_cache_path</code>&nbsp;指令来为代理的内容设置缓存。它会创建一个直接用于代理服务器返回的数据存储区域。<code>proxy_cache_path</code>&nbsp;指令必须在&nbsp;<code>http</code>&nbsp;的&nbsp;<strong>context</strong>&nbsp;中设置。</p>\r\n\r\n<p>下面例子中，我们将会配置这个和相关指令来设置我们的缓存系统。</p>\r\n\r\n<pre>\r\n<code># http context\r\n\r\nproxy_cache_path /var/lib/nginx/cache levels=1:2 keys_zone=backcache:8m max_size=50m;\r\nproxy_cache_key &quot;$scheme$request_method$host$request_uri$is_args$args&quot;;\r\nproxy_cache_valid 200 302 10m;\r\nproxy_cache_valid 404 1m;\r\n</code></pre>\r\n\r\n<p>我们可以使用&nbsp;<code>proxy_cache_path</code>&nbsp;指令来定义缓存的存储路径。在这个例子，我使用&nbsp;<code>/var/lib/nginx/cache</code>&nbsp;这个路径。如果这个路径不存在，你需要创建这个目录，并赋予正确的权限：</p>\r\n\r\n<pre>\r\n<code>sudo mkdir -p /var/lib/nginx/cache\r\nsudo chown www-data /var/lib/nginx/cache\r\nsudo chmod 700 /var/lib/nginx/cache\r\n</code></pre>\r\n\r\n<p>参数&nbsp;<code>levels=</code>&nbsp;用来指定缓存的组织形式。<strong>Nginx</strong>&nbsp;将会通过哈希键值创建一个缓存&nbsp;<strong>key</strong>（在下方配置）。上述我们选择的 level 采用 2 级目录结构，内存空间的大小是 8m，假设我们的哈希键值为&nbsp;<code>b7f54b2df7773722d382f4809d65087c</code>，那存储该内容的目录结构是：<code>/var/lib/nginx/cache/backcache/c/87/b7f54b2df7773722d382f4809d65087c</code>，注意到规律没有？参数&nbsp;<code>keys_zone=</code>&nbsp;定义缓存区域（我们称之为&nbsp;<code>backzone</code>）的名称。这个也是我们定义存储多少元数据的地方。在这个场景中，我们存储 8 MB 的键。<strong>Nginx</strong>&nbsp;将每一兆会存储 8000 个实体。参数&nbsp;<code>max_size</code>&nbsp;用来定义实际缓存数据的最大尺寸。</p>\r\n\r\n<p>现在，我归纳下：</p>\r\n\r\n<pre>\r\n<code>proxy_cache_path {cache_root:缓存路径} \r\n	levels={n:从缓存键值倒数n个字符作为一级目录}:{m:从缓存键值倒数第 n 个字符开始 m 个字符作为二级目录} \r\n	keys_zone={cache_name:该缓存在缓存路径的目录名}:8m;\r\n</code></pre>\r\n\r\n<p>最终该键缓存的目录结构是：</p>\r\n\r\n<pre>\r\n<code>{cache_root}/{cache_name}/{数字:从缓存键值倒数n个字符作为一级目录}/{从缓存键值倒数n个字符}/{从缓存键值倒数第 n 个字符开始 m 个字符作为二级目录}\r\n</code></pre>\r\n\r\n<p>上面我们使用的另一个指令就是&nbsp;<code>proxy_cache_key</code>。它用来设置用来存储缓存值的键。</p>\r\n\r\n<p><code>proxy_cache_valid</code>&nbsp;指令可以被指定多次。它允许我们基于不同状态码存储不同值。在我们的例子中，我们存储 ** 200 状态（成功）** 和&nbsp;<strong>302 状态（重定向）</strong>&nbsp;缓存时间为 10 分钟，和&nbsp;<strong>404 状态</strong>&nbsp;为 1 分钟后清除缓存。</p>\r\n\r\n<p>现在，我们已经配置好缓存区域，但是我们仍然需要告诉&nbsp;<strong>Nginx</strong>&nbsp;在哪里使用缓存。</p>\r\n\r\n<p>在我们定义代理到后端的&nbsp;<code>location</code>&nbsp;中，我们配置缓存的使用：</p>\r\n\r\n<pre>\r\n<code># server context\r\n\r\nlocation /proxy-me {\r\n    proxy_cache backcache;\r\n    proxy_cache_bypass $http_cache_control;\r\n    add_header X-Proxy-Cache $upstream_cache_status;\r\n\r\n    proxy_pass http://backend;\r\n}\r\n\r\n. . .\r\n</code></pre>\r\n\r\n<p>使用&nbsp;<code>proxy_cache</code>&nbsp;指令，我们可以指定所在&nbsp;<strong>context</strong>&nbsp;可以使用&nbsp;<code>backcache</code>&nbsp;的缓存区域。<strong>Nginx</strong>&nbsp;将在传递到后端之前检查可用的缓存实体。</p>\r\n\r\n<p><code>proxy_cache_bypass</code>&nbsp;指令用来设置&nbsp;<code>$http_cache_control</code>&nbsp;变量。它告知代理服务器发请求的客户端是否需要请求一个新鲜，未缓存版本的资源。</p>\r\n\r\n<p>我们还可以增加一个多余&nbsp;<strong>Headers</strong>&nbsp;信息（<code>X-Proxy-Cache</code>）。我们把这个&nbsp;<strong>Headers</strong>&nbsp;设置成&nbsp;<code>$upstream_cache_status</code>。它设置&nbsp;<strong>Headers</strong>&nbsp;来告知用户该&nbsp;<strong>request</strong>&nbsp;的缓存是否被命中，丢失，或者被绕过。在 debug 的时候，该配置特别有用；并且对客户端来说也很重要。</p>\r\n\r\n<h2>缓存结果的注意事项</h2>\r\n\r\n<p>缓存可以极大地提高代理服务器的性能。然而，配置缓存的时候，还是要需要考虑挺多的东西的。</p>\r\n\r\n<p>首先，任何用户相关的数据都不应该被缓存。因为这样会导致一个用户数据的结果被呈现到另一个用户。如果你的站点是纯静态的，那这可能就不是问题了。</p>\r\n\r\n<p>如果你的站点有些动态元素，那你就需要在后端服务器考虑到这一点。处理它的方式依赖于后端处理方式。对于隐私内容，你应该把&nbsp;<code>Cache-Control</code>&nbsp;设置成&nbsp;<code>no-cache</code>,<code>no-store</code>,或者&nbsp;<code>private</code>，这个依赖于数据本身：</p>\r\n\r\n<ul>\r\n	<li><code>no-cache</code>:表示必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。</li>\r\n	<li><code>no-store</code>：直接禁止浏览器和所有中继缓存存储返回的任何版本的响应 - 例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</li>\r\n	<li><code>private</code>:浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。这个在缓存用户浏览器数据的时候很有用，但是代理服务器不会在后续的请求中承认数据的有效性。</li>\r\n	<li><code>public</code>:说明请求的是公共信息，它可以被任意的缓存。</li>\r\n</ul>\r\n\r\n<p>控制这个行为相关的&nbsp;<strong>Headers</strong>&nbsp;还有&nbsp;<code>max-age</code>，它控制资源缓存的过期时间。</p>\r\n\r\n<p>根据数据的敏感度，正确地设置这些&nbsp;<strong>Headers</strong>，将会帮助你有效地利用缓存，既能保障你的隐私数据安全的同时，还能让动态内容进行有效地刷新。</p>\r\n\r\n<p>如果你的后端服务器也使用&nbsp;<strong>Nginx</strong>，你可以像下面这样使用&nbsp;<code>expires</code>&nbsp;指令，它将会为&nbsp;<code>Cache-Control</code>&nbsp;设置&nbsp;<code>max-age</code>:</p>\r\n\r\n<pre>\r\n<code>location / {\r\n    expires 60m;	# 给请求的 Header 添加 Cache-Control:max-age=3660;\r\n}\r\n\r\nlocation /check-me {\r\n    expires -1; # 给请求的 Headers 添加 Cache-Control:no-cache;\r\n}\r\n</code></pre>\r\n\r\n<p>在上面的例子中，第一个块允许内容被缓存 60 分钟。第二个块则把&nbsp;<code>Cache-Control</code>&nbsp;头设置成&nbsp;<code>no-cache</code>。还想设置其他值，你可以使用&nbsp;<code>add_header</code>&nbsp;指令：</p>\r\n\r\n<pre>\r\n<code>location /private {\r\n    expires -1;\r\n    add_header Cache-Control &quot;no-store&quot;;\r\n    # 给请求的 Headers 添加 Cache-Control:no-cache, no-store;\r\n}\r\n</code></pre>\r\n\r\n<h2>结语</h2>\r\n\r\n<p><strong>Nginx</strong>&nbsp;是第一个也是最重要的反向代理服务器，还可以作为 Web 服务器使用。因为这样的设计决策，代理请求到另个服务器变得更简单。<strong>Nginx</strong>&nbsp;也足够灵活，允许你根据需求对代理配置进行灵活的控制。</p>\r\n',3,'孟祥坤','4d2e21b5-2fc0-4958-bd0a-012e0173d06f.png'),(65,'java','SpringMVC的web.xml配置详解','2017-08-23 20:22:25',NULL,'使用SpringMVC中web.xml的配置详解','<p>1、<a href=\"http://lib.csdn.net/base/javaee\" target=\"_blank\" title=\"Java EE知识库\">spring</a>&nbsp;框架解决字符串编码问题：过滤器&nbsp;<strong>CharacterEncodingFilter</strong>（filter-name）&nbsp;<br />\r\n2、在web.xml配置监听器<strong>ContextLoaderListener</strong>（listener-class）&nbsp;<br />\r\nContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。&nbsp;<br />\r\n3、部署applicationContext的xml文件：<strong>contextConfigLocation</strong>（context-param下的param-name）&nbsp;<br />\r\n4、DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据某某规则分发到目标Controller(我们写的Action)来处理。&nbsp;<br />\r\n<strong>DispatcherServlet</strong>（servlet-name、servlet-class、init-param、param-name(contextConfigLocation)、param-value）&nbsp;<br />\r\n在DispatcherServlet的初始化过程中，框架会在web应用的 WEB-INF文件夹下寻找名为[servlet-name]-servlet.xml 的配置文件，生成文件中定义的bean</p>\r\n\r\n<pre>\r\n<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \r\n&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  \r\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  \r\n         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;  \r\n\r\n    &lt;!-- 在Spring框架中是如何解决从页面传来的字符串的编码问题的呢？\r\n    下面我们来看看Spring框架给我们提供过滤器CharacterEncodingFilter  \r\n     这个过滤器就是针对于每次浏览器请求进行过滤的，然后再其之上添加了父类没有的功能即处理字符编码。  \r\n      其中encoding用来设置编码格式，forceEncoding用来设置是否理会 request.getCharacterEncoding()方法，设置为true则强制覆盖之前的编码格式。--&gt;  \r\n    &lt;filter&gt;  \r\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;  \r\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  \r\n        &lt;init-param&gt;  \r\n            &lt;param-name&gt;encoding&lt;/param-name&gt;  \r\n            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  \r\n        &lt;/init-param&gt;  \r\n        &lt;init-param&gt;  \r\n            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;  \r\n            &lt;param-value&gt;true&lt;/param-value&gt;  \r\n        &lt;/init-param&gt;  \r\n    &lt;/filter&gt;  \r\n    &lt;filter-mapping&gt;  \r\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;  \r\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  \r\n    &lt;/filter-mapping&gt;  \r\n    &lt;!-- 项目中使用Spring 时，applicationContext.xml配置文件中并没有BeanFactory，要想在业务层中的class 文件中直接引用Spring容器管理的bean可通过以下方式--&gt;  \r\n    &lt;!--1、在web.xml配置监听器ContextLoaderListener--&gt;  \r\n    &lt;!--ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。  \r\n    在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。  \r\n    它的API说明  \r\n    第一段说明ContextLoader可以由 ContextLoaderListener和ContextLoaderServlet生成。  \r\n    如果查看ContextLoaderServlet的API，可以看到它也关联了ContextLoader这个类而且它实现了HttpServlet这个接口  \r\n    第二段，ContextLoader创建的是 XmlWebApplicationContext这样一个类，它实现的接口是WebApplicationContext-&gt;ConfigurableWebApplicationContext-&gt;ApplicationContext-&gt;  \r\n    BeanFactory这样一来spring中的所有bean都由这个类来创建  \r\n     IUploaddatafileManager uploadmanager = (IUploaddatafileManager)    ContextLoaderListener.getCurrentWebApplicationContext().getBean(&quot;uploadManager&quot;);\r\n     --&gt;  \r\n    &lt;listener&gt;  \r\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  \r\n    &lt;/listener&gt;  \r\n    &lt;!--2、部署applicationContext的xml文件--&gt;  \r\n    &lt;!--如果在web.xml中不写任何参数配置信息，默认的路径是&quot;/WEB-INF/applicationContext.xml，  \r\n    在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml。  \r\n    如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：  \r\n    在&lt;param-value&gt; &lt;/param-value&gt;里指定相应的xml文件名，如果有多个xml文件，可以写在一起并以&ldquo;,&rdquo;号分隔。  \r\n    也可以这样applicationContext-*.xml采用通配符，比如这那个目录下有applicationContext-ibatis-base.xml，  \r\n    applicationContext-action.xml，applicationContext-ibatis-dao.xml等文件，都会一同被载入。  \r\n    在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。--&gt;  \r\n    &lt;context-param&gt;  \r\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  \r\n        &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt;  \r\n    &lt;/context-param&gt;  \r\n\r\n    &lt;!--如果你的DispatcherServlet拦截&quot;/&quot;，为了实现REST风格，拦截了所有的请求，那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。--&gt;  \r\n    &lt;!--方案一：激活Tomcat的defaultServlet来处理静态文件--&gt;  \r\n    &lt;!--要写在DispatcherServlet的前面， 让 defaultServlet先拦截请求，这样请求就不会进入Spring了，我想性能是最好的吧。--&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.xml&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.json&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;servlet-name&gt;default&lt;/servlet-name&gt;  \r\n        &lt;url-pattern&gt;*.map&lt;/url-pattern&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n    &lt;!--使用Spring MVC,配置DispatcherServlet是第一步。DispatcherServlet是一个Servlet,,所以可以配置多个DispatcherServlet--&gt;  \r\n    &lt;!--DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据某某规则分发到目标Controller(我们写的Action)来处理。--&gt;  \r\n    &lt;servlet&gt;  \r\n        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;!--在DispatcherServlet的初始化过程中，框架会在web应用的 WEB-INF文件夹下寻找名为[servlet-name]-servlet.xml 的配置文件，生成文件中定义的bean。--&gt;  \r\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  \r\n        &lt;!--指明了配置文件的文件名，不使用默认配置文件名，而使用dispatcher-servlet.xml配置文件。--&gt;  \r\n        &lt;init-param&gt;  \r\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  \r\n            &lt;!--其中&lt;param-value&gt;**.xml&lt;/param-value&gt; 这里可以使用多种写法--&gt;  \r\n            &lt;!--1、不写,使用默认值:/WEB-INF/&lt;servlet-name&gt;-servlet.xml--&gt;  \r\n            &lt;!--2、&lt;param-value&gt;/WEB-INF/classes/dispatcher-servlet.xml&lt;/param-value&gt;--&gt;  \r\n            &lt;!--3、&lt;param-value&gt;classpath*:dispatcher-servlet.xml&lt;/param-value&gt;--&gt;  \r\n            &lt;!--4、多个值用逗号分隔--&gt;  \r\n            &lt;param-value&gt;classpath:spring/dispatcher-servlet.xml&lt;/param-value&gt;  \r\n        &lt;/init-param&gt;  \r\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--是启动顺序，让这个Servlet随Servletp容器一起启动。--&gt;  \r\n    &lt;/servlet&gt;  \r\n    &lt;servlet-mapping&gt;  \r\n        &lt;!--这个Servlet的名字是dispatcher，可以有多个DispatcherServlet，是通过名字来区分的。每一个DispatcherServlet有自己的WebApplicationContext上下文对象。同时保存的ServletContext中和Request对象中.--&gt;  \r\n        &lt;!--ApplicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用&ldquo;容器&rdquo;来表述它更容易理解一些，ApplicationContext则是&ldquo;应用的容器&rdquo;了:P，Spring把Bean放在这个容器中，在需要的时候，用getBean方法取出--&gt;  \r\n        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  \r\n        &lt;!--Servlet拦截匹配规则可以自已定义，当映射为@RequestMapping(&quot;/user/add&quot;)时，为例,拦截哪种URL合适？--&gt;  \r\n        &lt;!--1、拦截*.do、*.htm， 例如：/user/add.do,这是最传统的方式，最简单也最实用。不会导致静态文件（jpg,js,css）被拦截。--&gt;  \r\n        &lt;!--2、拦截/，例如：/user/add,可以实现现在很流行的REST风格。很多互联网类型的应用很喜欢这种风格的URL。弊端：会导致静态文件（jpg,js,css）被拦截后不能正常显示。 --&gt;  \r\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带&ldquo;/&rdquo;的请求。--&gt;  \r\n    &lt;/servlet-mapping&gt;  \r\n\r\n    &lt;welcome-file-list&gt;&lt;!--指定欢迎页面--&gt;  \r\n        &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;  \r\n    &lt;/welcome-file-list&gt;  \r\n    &lt;error-page&gt; &lt;!--当系统出现404错误，跳转到页面nopage.html--&gt;  \r\n        &lt;error-code&gt;404&lt;/error-code&gt;  \r\n        &lt;location&gt;/nopage.html&lt;/location&gt;  \r\n    &lt;/error-page&gt;  \r\n    &lt;error-page&gt; &lt;!--当系统出现java.lang.NullPointerException，跳转到页面error.html--&gt;  \r\n        &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt;  \r\n        &lt;location&gt;/error.html&lt;/location&gt;  \r\n    &lt;/error-page&gt;  \r\n    &lt;session-config&gt;&lt;!--会话超时配置，单位分钟--&gt;  \r\n        &lt;session-timeout&gt;360&lt;/session-timeout&gt;  \r\n    &lt;/session-config&gt;  \r\n&lt;/web-app&gt;  </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>转载自：<a href=\"http://blog.csdn.net/u010796790\">http://blog.csdn.net/u010796790</a></p>\r\n',3,'孟祥坤','735e775f-4ead-453a-b98c-21e2260983aa.png');

/*Table structure for table `content` */

DROP TABLE IF EXISTS `content`;

CREATE TABLE `content` (
  `id` int(11) NOT NULL,
  `content` text COLLATE utf8_unicode_ci,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `content` */

/*Table structure for table `countinfo` */

DROP TABLE IF EXISTS `countinfo`;

CREATE TABLE `countinfo` (
  `ip` varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,
  `userid` int(10) DEFAULT NULL,
  `date` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `countinfo` */

insert  into `countinfo`(`ip`,`userid`,`date`) values (NULL,NULL,NULL);

/*Table structure for table `type` */

DROP TABLE IF EXISTS `type`;

CREATE TABLE `type` (
  `type` varchar(10) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `type` */

insert  into `type`(`type`) values ('java'),('Linux'),('other'),('python'),('主页文章'),('数据库'),('生活点滴');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(15) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(25) COLLATE utf8_unicode_ci NOT NULL,
  `passwd` varchar(30) COLLATE utf8_unicode_ci NOT NULL,
  `createdate` datetime DEFAULT NULL,
  `phone` varchar(15) COLLATE utf8_unicode_ci DEFAULT NULL,
  `email` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL,
  `qq` varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,
  `isadmin` tinyint(1) DEFAULT '0',
  `islogin` int(1) DEFAULT '0',
  `avatar` varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `username_idx` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

/*Data for the table `user` */

insert  into `user`(`id`,`username`,`passwd`,`createdate`,`phone`,`email`,`qq`,`isadmin`,`islogin`,`avatar`) values (1,'孟祥坤','mxk15235674396','2017-08-12 11:25:51','18835934360','947139299@qq.com','947139299',1,0,NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
